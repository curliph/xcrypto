
tool_options {

}


formal_environment fw_hw_crypto_cop {

    define CLOCK  {% vtx_clk %}
    define RESET  {% vtx_resetn %}

    property_inputs default_inputs {
               vtx_clk          ;
               vtx_reset        ; 
               vtx_valid        ; 
        [31:0] vtx_instr_enc    ; 
        [31:0] vtx_instr_rs1    ; 
        [ 2:0] vtx_instr_result ; 
        [31:0] vtx_instr_wdata  ; 
        [ 4:0] vtx_instr_waddr  ; 
               vtx_instr_wen    ;

               vtx_mem_cen_0   ;
               vtx_mem_wen_0   ;
        [31:0] vtx_mem_addr_0  ;
        [31:0] vtx_mem_wdata_0 ;
        [31:0] vtx_mem_rdata_0 ;
        [ 3:0] vtx_mem_ben_0   ;
               vtx_mem_error_0 ;
               
               vtx_mem_cen_1   ;
               vtx_mem_wen_1   ;
        [31:0] vtx_mem_addr_1  ;
        [31:0] vtx_mem_wdata_1 ;
        [31:0] vtx_mem_rdata_1 ;
        [ 3:0] vtx_mem_ben_1   ;
               vtx_mem_error_1 ;

               vtx_mem_cen_2   ;
               vtx_mem_wen_2   ;
        [31:0] vtx_mem_addr_2  ;
        [31:0] vtx_mem_wdata_2 ;
        [31:0] vtx_mem_rdata_2 ;
        [ 3:0] vtx_mem_ben_2   ;
               vtx_mem_error_2 ;
               
               vtx_mem_cen_3   ;
               vtx_mem_wen_3   ;
        [31:0] vtx_mem_addr_3  ;
        [31:0] vtx_mem_wdata_3 ;
        [31:0] vtx_mem_rdata_3 ;
        [ 3:0] vtx_mem_ben_3   ;
               vtx_mem_error_3 ;

        [31:0] _0_vtx_cprs_pre;
        [31:0] _1_vtx_cprs_pre;
        [31:0] _2_vtx_cprs_pre;
        [31:0] _3_vtx_cprs_pre;
        [31:0] _4_vtx_cprs_pre;
        [31:0] _5_vtx_cprs_pre;
        [31:0] _6_vtx_cprs_pre;
        [31:0] _7_vtx_cprs_pre;
        [31:0] _8_vtx_cprs_pre;
        [31:0] _9_vtx_cprs_pre;
        [31:0] _10_vtx_cprs_pre;
        [31:0] _11_vtx_cprs_pre;
        [31:0] _12_vtx_cprs_pre;
        [31:0] _13_vtx_cprs_pre;
        [31:0] _14_vtx_cprs_pre;
        [31:0] _15_vtx_cprs_pre;
        
        [31:0] _0_vtx_cprs_post;
        [31:0] _1_vtx_cprs_post;
        [31:0] _2_vtx_cprs_post;
        [31:0] _3_vtx_cprs_post;
        [31:0] _4_vtx_cprs_post;
        [31:0] _5_vtx_cprs_post;
        [31:0] _6_vtx_cprs_post;
        [31:0] _7_vtx_cprs_post;
        [31:0] _8_vtx_cprs_post;
        [31:0] _9_vtx_cprs_post;
        [31:0] _10_vtx_cprs_post;
        [31:0] _11_vtx_cprs_post;
        [31:0] _12_vtx_cprs_post;
        [31:0] _13_vtx_cprs_post;
        [31:0] _14_vtx_cprs_post;
        [31:0] _15_vtx_cprs_post;

    }
    
    //
    // This gets pasted into the top of the formal environment.
    //
    fe_preamble {%
        `include "fml_pack_widths.vh"
    %}

    property_context instruction_pc (
        *default_inputs;
    ){
        helper_logic (verilog) {%

            // Include the "common" code for things like constants.
            `include "scarv_cop_common.vh"
            
            // Include the generated decoder.
            wire [31:0] encoded = vtx_instr_enc;
            `include "ise_decode.v"
            
            wire [31:0] vtx_cprs_pre [15:0]; \
            wire [31:0] vtx_cprs_post[15:0]; \
            (*keep*)wire [31:0] vtx_crd_val_pre = vtx_cprs_pre[dec_arg_crd]; 
            (*keep*)wire [31:0] vtx_crs1_val_pre = vtx_cprs_pre[dec_arg_crs1];
            (*keep*)wire [31:0] vtx_crs2_val_pre = vtx_cprs_pre[dec_arg_crs2];
            (*keep*)wire [31:0] vtx_crs3_val_pre = vtx_cprs_pre[dec_arg_crs3];
            (*keep*)wire [31:0] vtx_crd_val_post = vtx_cprs_post[dec_arg_crd];
            (*keep*)wire [31:0] vtx_crs1_val_post = vtx_cprs_post[dec_arg_crs1];
            (*keep*)wire [31:0] vtx_crs2_val_post = vtx_cprs_post[dec_arg_crs2];
            (*keep*)wire [31:0] vtx_crs3_val_post = vtx_cprs_post[dec_arg_crs3];
                
            assign vtx_cprs_pre[0 ] = _0_vtx_cprs_pre;
            assign vtx_cprs_pre[1 ] = _1_vtx_cprs_pre;
            assign vtx_cprs_pre[2 ] = _2_vtx_cprs_pre;
            assign vtx_cprs_pre[3 ] = _3_vtx_cprs_pre;
            assign vtx_cprs_pre[4 ] = _4_vtx_cprs_pre;
            assign vtx_cprs_pre[5 ] = _5_vtx_cprs_pre;
            assign vtx_cprs_pre[6 ] = _6_vtx_cprs_pre;
            assign vtx_cprs_pre[7 ] = _7_vtx_cprs_pre;
            assign vtx_cprs_pre[8 ] = _8_vtx_cprs_pre;
            assign vtx_cprs_pre[9 ] = _9_vtx_cprs_pre;
            assign vtx_cprs_pre[10] = _10_vtx_cprs_pre;
            assign vtx_cprs_pre[11] = _11_vtx_cprs_pre;
            assign vtx_cprs_pre[12] = _12_vtx_cprs_pre;
            assign vtx_cprs_pre[13] = _13_vtx_cprs_pre;
            assign vtx_cprs_pre[14] = _14_vtx_cprs_pre;
            assign vtx_cprs_pre[15] = _15_vtx_cprs_pre;
            
            assign vtx_cprs_post[0 ] = _0_vtx_cprs_post;
            assign vtx_cprs_post[1 ] = _1_vtx_cprs_post;
            assign vtx_cprs_post[2 ] = _2_vtx_cprs_post;
            assign vtx_cprs_post[3 ] = _3_vtx_cprs_post;
            assign vtx_cprs_post[4 ] = _4_vtx_cprs_post;
            assign vtx_cprs_post[5 ] = _5_vtx_cprs_post;
            assign vtx_cprs_post[6 ] = _6_vtx_cprs_post;
            assign vtx_cprs_post[7 ] = _7_vtx_cprs_post;
            assign vtx_cprs_post[8 ] = _8_vtx_cprs_post;
            assign vtx_cprs_post[9 ] = _9_vtx_cprs_post;
            assign vtx_cprs_post[10] = _10_vtx_cprs_post;
            assign vtx_cprs_post[11] = _11_vtx_cprs_post;
            assign vtx_cprs_post[12] = _12_vtx_cprs_post;
            assign vtx_cprs_post[13] = _13_vtx_cprs_post;
            assign vtx_cprs_post[14] = _14_vtx_cprs_post;
            assign vtx_cprs_post[15] = _15_vtx_cprs_post;

        %}

    }

    //
    // Simple checks which should be applied to every instruction
    // regardless of what it does.
    //
    property_context generic_instr_checks extends instruction_pc(
    ) {
        
        on (*CLOCK) if {% vtx_valid && vtx_reset %} {

            if {% dec_invalid_opcode %} {
            
                // Check that given an invalid opcode, we always get the
                // correct instruction response / result code.
                assert {% vtx_instr_result == SCARV_COP_INSN_BAD_INS %}

                // We should never try to write back to the CPU
                // on an invalid opcode
                assert {% vtx_instr_wen == 1'b0 %}
            }
            
            // Check that the result encoding is always valid and never
            // a reserved value.
            assert {%
                vtx_instr_result == SCARV_COP_INSN_SUCCESS ||
                vtx_instr_result == SCARV_COP_INSN_ABORT   ||
                vtx_instr_result == SCARV_COP_INSN_BAD_INS ||
                vtx_instr_result == SCARV_COP_INSN_BAD_LAD ||
                vtx_instr_result == SCARV_COP_INSN_BAD_SAD ||
                vtx_instr_result == SCARV_COP_INSN_LD_ERR  ||
                vtx_instr_result == SCARV_COP_INSN_ST_ERR 
            %}

        }
    }


    //
    // Property context for pack instructions
    //
    property_context instr_packed extends instruction_pc (
    ) {

        helper_logic (verilog) {%
            // Pack width of the instruction
            wire [2:0] pw = 
                {vtx_instr_enc[24],vtx_instr_enc[19],vtx_instr_enc[11]};

            wire pw_valid = 
                pw == SCARV_COP_PW_1  ||
                pw == SCARV_COP_PW_2  ||
                pw == SCARV_COP_PW_4  ||
                pw == SCARV_COP_PW_8  ||
                pw == SCARV_COP_PW_16  ;
        %}
        
    }
        

    //
    // Property context for add.px
    //
    property_context instr_add_px extends instr_packed (
    ) {

        helper_logic (verilog) {%
            // Compute expected result into register called "result". See
            // `verif/formal/fml_pack_widths.vh` for macro definition.
            `PACK_WIDTH_ARITH_OPERATION_RESULT(+)
        %}
        
        on (*CLOCK) if {% vtx_valid && vtx_reset && dec_add_px %} {
            
            //
            // Make sure we have the correct pack widths.
            if {% pw_valid %} {
                assert {% vtx_instr_result == SCARV_COP_INSN_SUCCESS %}
            } else {
                assert {% vtx_instr_result == SCARV_COP_INSN_BAD_INS %}
            }

            //
            // Check the correct results for a given pack width.

            assert{% vtx_crd_val_post == result_pw1 %}
                assuming {% pw == SCARV_COP_PW_1 %}

            assert{% vtx_crd_val_post == result_pw2 %}
                assuming {% pw == SCARV_COP_PW_2 %}

            assert{% vtx_crd_val_post == result_pw4 %}
                assuming {% pw == SCARV_COP_PW_4 %}

            assert{% vtx_crd_val_post == result_pw8 %}
                assuming {% pw == SCARV_COP_PW_8 %}

            assert{% vtx_crd_val_post == result_pw16 %}
                assuming {% pw == SCARV_COP_PW_16 %}

            //
            // Make sure that no packed instruction tries to write
            // back to the GPRs
            assert {% vtx_instr_wen == 1'b0 %}
        }
    }

}
