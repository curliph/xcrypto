
tool_options {

}


formal_environment fw_hw_crypto_cop {

    define CLOCK  {% vtx_clk %}
    define RESET  {% vtx_resetn %}

    property_inputs default_inputs {
               vtx_clk          ;
               vtx_reset        ; 
               vtx_valid        ; 
        [31:0] vtx_instr_enc    ; 
        [31:0] vtx_instr_rs1    ; 
        [ 2:0] vtx_instr_result ; 
        [31:0] vtx_instr_wdata  ; 
        [ 4:0] vtx_instr_waddr  ; 
               vtx_instr_wen    ;

               vtx_mem_cen_0   ;
               vtx_mem_wen_0   ;
        [31:0] vtx_mem_addr_0  ;
        [31:0] vtx_mem_wdata_0 ;
        [31:0] vtx_mem_rdata_0 ;
        [ 3:0] vtx_mem_ben_0   ;
               vtx_mem_error_0 ;
               
               vtx_mem_cen_1   ;
               vtx_mem_wen_1   ;
        [31:0] vtx_mem_addr_1  ;
        [31:0] vtx_mem_wdata_1 ;
        [31:0] vtx_mem_rdata_1 ;
        [ 3:0] vtx_mem_ben_1   ;
               vtx_mem_error_1 ;

               vtx_mem_cen_2   ;
               vtx_mem_wen_2   ;
        [31:0] vtx_mem_addr_2  ;
        [31:0] vtx_mem_wdata_2 ;
        [31:0] vtx_mem_rdata_2 ;
        [ 3:0] vtx_mem_ben_2   ;
               vtx_mem_error_2 ;
               
               vtx_mem_cen_3   ;
               vtx_mem_wen_3   ;
        [31:0] vtx_mem_addr_3  ;
        [31:0] vtx_mem_wdata_3 ;
        [31:0] vtx_mem_rdata_3 ;
        [ 3:0] vtx_mem_ben_3   ;
               vtx_mem_error_3 ;

        [31:0] _0_vtx_cprs_pre;
        [31:0] _1_vtx_cprs_pre;
        [31:0] _2_vtx_cprs_pre;
        [31:0] _3_vtx_cprs_pre;
        [31:0] _4_vtx_cprs_pre;
        [31:0] _5_vtx_cprs_pre;
        [31:0] _6_vtx_cprs_pre;
        [31:0] _7_vtx_cprs_pre;
        [31:0] _8_vtx_cprs_pre;
        [31:0] _9_vtx_cprs_pre;
        [31:0] _10_vtx_cprs_pre;
        [31:0] _11_vtx_cprs_pre;
        [31:0] _12_vtx_cprs_pre;
        [31:0] _13_vtx_cprs_pre;
        [31:0] _14_vtx_cprs_pre;
        [31:0] _15_vtx_cprs_pre;
        
        [31:0] _0_vtx_cprs_post;
        [31:0] _1_vtx_cprs_post;
        [31:0] _2_vtx_cprs_post;
        [31:0] _3_vtx_cprs_post;
        [31:0] _4_vtx_cprs_post;
        [31:0] _5_vtx_cprs_post;
        [31:0] _6_vtx_cprs_post;
        [31:0] _7_vtx_cprs_post;
        [31:0] _8_vtx_cprs_post;
        [31:0] _9_vtx_cprs_post;
        [31:0] _10_vtx_cprs_post;
        [31:0] _11_vtx_cprs_post;
        [31:0] _12_vtx_cprs_post;
        [31:0] _13_vtx_cprs_post;
        [31:0] _14_vtx_cprs_post;
        [31:0] _15_vtx_cprs_post;

    }

    property_context instruction_pc (
        *default_inputs;
    ){
        helper_logic (verilog) {%

            // Include the "common" code for things like constants.
            `include "scarv_cop_common.vh"
            
            // Include the generated decoder.
            wire [31:0] encoded = vtx_instr_enc;
            `include "ise_decode.v"
            
            wire [31:0] vtx_cprs_pre [15:0]; \
            wire [31:0] vtx_cprs_post[15:0]; \
            (*keep*)wire [31:0] vtx_crd_val_pre = vtx_cprs_pre[dec_arg_crd]; 
            (*keep*)wire [31:0] vtx_crs1_val_pre = vtx_cprs_pre[dec_arg_crs1];
            (*keep*)wire [31:0] vtx_crs2_val_pre = vtx_cprs_pre[dec_arg_crs2];
            (*keep*)wire [31:0] vtx_crs3_val_pre = vtx_cprs_pre[dec_arg_crs3];
            (*keep*)wire [31:0] vtx_crd_val_post = vtx_cprs_post[dec_arg_crd];
            (*keep*)wire [31:0] vtx_crs1_val_post = vtx_cprs_post[dec_arg_crs1];
            (*keep*)wire [31:0] vtx_crs2_val_post = vtx_cprs_post[dec_arg_crs2];
            (*keep*)wire [31:0] vtx_crs3_val_post = vtx_cprs_post[dec_arg_crs3];
                
            assign vtx_cprs_pre[0 ] = _0_vtx_cprs_pre;
            assign vtx_cprs_pre[1 ] = _1_vtx_cprs_pre;
            assign vtx_cprs_pre[2 ] = _2_vtx_cprs_pre;
            assign vtx_cprs_pre[3 ] = _3_vtx_cprs_pre;
            assign vtx_cprs_pre[4 ] = _4_vtx_cprs_pre;
            assign vtx_cprs_pre[5 ] = _5_vtx_cprs_pre;
            assign vtx_cprs_pre[6 ] = _6_vtx_cprs_pre;
            assign vtx_cprs_pre[7 ] = _7_vtx_cprs_pre;
            assign vtx_cprs_pre[8 ] = _8_vtx_cprs_pre;
            assign vtx_cprs_pre[9 ] = _9_vtx_cprs_pre;
            assign vtx_cprs_pre[10] = _10_vtx_cprs_pre;
            assign vtx_cprs_pre[11] = _11_vtx_cprs_pre;
            assign vtx_cprs_pre[12] = _12_vtx_cprs_pre;
            assign vtx_cprs_pre[13] = _13_vtx_cprs_pre;
            assign vtx_cprs_pre[14] = _14_vtx_cprs_pre;
            assign vtx_cprs_pre[15] = _15_vtx_cprs_pre;
            
            assign vtx_cprs_post[0 ] = _0_vtx_cprs_post;
            assign vtx_cprs_post[1 ] = _1_vtx_cprs_post;
            assign vtx_cprs_post[2 ] = _2_vtx_cprs_post;
            assign vtx_cprs_post[3 ] = _3_vtx_cprs_post;
            assign vtx_cprs_post[4 ] = _4_vtx_cprs_post;
            assign vtx_cprs_post[5 ] = _5_vtx_cprs_post;
            assign vtx_cprs_post[6 ] = _6_vtx_cprs_post;
            assign vtx_cprs_post[7 ] = _7_vtx_cprs_post;
            assign vtx_cprs_post[8 ] = _8_vtx_cprs_post;
            assign vtx_cprs_post[9 ] = _9_vtx_cprs_post;
            assign vtx_cprs_post[10] = _10_vtx_cprs_post;
            assign vtx_cprs_post[11] = _11_vtx_cprs_post;
            assign vtx_cprs_post[12] = _12_vtx_cprs_post;
            assign vtx_cprs_post[13] = _13_vtx_cprs_post;
            assign vtx_cprs_post[14] = _14_vtx_cprs_post;
            assign vtx_cprs_post[15] = _15_vtx_cprs_post;

        %}

    }

    //
    // Simple checks which should be applied to every instruction
    // regardless of what it does.
    //
    property_context generic_instr_checks extends instruction_pc(
        *default_inputs;
    ) {
        
        on (*CLOCK) if {% vtx_valid && vtx_reset %} {

            if {% dec_invalid_opcode %} {
            
                // Check that given an invalid opcode, we always get the
                // correct instruction response / result code.
                assert {% vtx_instr_result == SCARV_COP_INSN_BAD_INS %}

                // We should never try to write back to the CPU
                // on an invalid opcode
                assert {% vtx_instr_wen == 1'b0 %}
            }
            
            // Check that the result encoding is always valid and never
            // a reserved value.
            assert {%
                vtx_instr_result == SCARV_COP_INSN_SUCCESS ||
                vtx_instr_result == SCARV_COP_INSN_ABORT   ||
                vtx_instr_result == SCARV_COP_INSN_BAD_INS ||
                vtx_instr_result == SCARV_COP_INSN_BAD_LAD ||
                vtx_instr_result == SCARV_COP_INSN_BAD_SAD ||
                vtx_instr_result == SCARV_COP_INSN_LD_ERR  ||
                vtx_instr_result == SCARV_COP_INSN_ST_ERR 
            %}

        }
    }

}
