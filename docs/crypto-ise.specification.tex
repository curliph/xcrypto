
This section specifies the ISE in terms of it's state and the instructions
which operate on that state.

\subsection{Notation}

Lorem ipsum doler set amet.


\subsection{State}

The ISE introduces an additional $16$ by $32$-bit register file. It can
be accessed in {\em standard} mode or {\em transposed} mode.

The addressing is shown diagramatically in table \ref{tab:state-addr}.

Because there are 32 RISC-V $\GPR$s and only 16 ISE $\CPR$s, the spare
register address bit in the ISE instruction encodings is used to determine
whether to access the register file in standard or transpose mode. In this
case, the {\em top} 16 register addresses access transpose mode, while the
{\em bottom} 16 register addresses access standard mode. \designnote{
    This introduces some complexities with regard to forwarding register
    values in a pipelined design, since one must identify hazards on a 
    per-byte basis, rather than on a per-word basis.
}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l l l l|}
\hline
\multicolumn{1}{|l|}{2:0} & \textbf{ } & \textbf{ } & \textbf{ } & \textbf{ } \\ \hline
\textbf{0 }   & r0.3       & r0.2       & r0.1       & r0.0       \\ \hline
\textbf{1 }   & r1.3       & r1.2       & r1.1       & r1.0       \\ \hline
\textbf{2 }   & r2.3       & r2.2       & r2.1       & r2.0       \\ \hline
\textbf{3 }   & r3.3       & r3.2       & r3.1       & r3.0       \\ \hline
\textbf{4 }   & r4.3       & r4.2       & r4.1       & r4.0       \\ \hline
\textbf{5 }   & r5.3       & r5.2       & r5.1       & r5.0       \\ \hline
\textbf{6 }   & r6.3       & r6.2       & r6.1       & r6.0       \\ \hline
\textbf{7 }   & r7.3       & r7.2       & r7.1       & r7.0       \\ \hline
\textbf{8 }   & r8.3       & r8.2       & r8.1       & r8.0       \\ \hline
\textbf{9 }   & r9.3       & r9.2       & r9.1       & r9.0       \\ \hline
\textbf{10}   & r10.3      & r10.2      & r10.1      & r10.0      \\ \hline
\textbf{11}   & r11.3      & r11.2      & r11.1      & r11.0      \\ \hline
\textbf{12}   & r12.3      & r12.2      & r12.1      & r12.0      \\ \hline
\textbf{13}   & r13.3      & r13.2      & r13.1      & r13.0      \\ \hline
\textbf{14}   & r14.3      & r14.2      & r14.1      & r14.0      \\ \hline
\textbf{15}   & r15.3      & r15.2      & r15.1      & r15.0      \\ \hline
\end{tabular}
\quad
\begin{tabular}{|l|l|l|l|l|}
\hline
\multicolumn{1}{|l|}{2:1 \textbackslash 1:0} & \textbf{3} & \textbf{2} & \textbf{1} & \textbf{0} \\ \hline
\multirow{4}{*}{\textbf{0}} & r19.0   & r18.0   & r17.0   & r16.0   \\
                            & r19.1   & r18.1   & r17.1   & r16.1   \\
                            & r19.2   & r18.2   & r17.2   & r16.2   \\
                            & r19.3   & r18.3   & r17.3   & r16.3   \\ \hline
\multirow{4}{*}{\textbf{1}} & r23.0   & r22.0   & r21.0   & r20.0   \\
                            & r23.1   & r22.1   & r21.1   & r20.1   \\
                            & r23.2   & r22.2   & r21.2   & r20.2   \\
                            & r23.3   & r22.3   & r21.3   & r20.3   \\ \hline
\multirow{4}{*}{\textbf{2}} & r27.0   & r26.0   & r25.0   & r24.0   \\
                            & r27.1   & r26.1   & r25.1   & r24.1   \\
                            & r27.2   & r26.2   & r25.2   & r24.2   \\
                            & r27.3   & r26.3   & r25.3   & r24.3   \\ \hline
\multirow{4}{*}{\textbf{3}} & r31.0   & r30.0   & r29.0   & r28.0   \\
                            & r31.1   & r30.1   & r29.1   & r28.1   \\
                            & r31.2   & r30.2   & r29.2   & r28.2   \\
                            & r31.3   & r30.3   & r29.3   & r28.3   \\ \hline
\end{tabular}
\caption{These two table show the per-byte layoute in standard and transposed
addressing modes. On the left is the standard addressing mode, where the
4-bit register address corresponds to rows in the table. On the right
is the transposed mode, where registers are addressed in four rows of
four columns.}
\label{tab:state-addr}
\end{table}

Unlike the RISC-V $\GPR$s, the zeroth $\CPR$ is not tied to zero.

\subsubsection{ABI Standards}

All of the state added in the Crypto ISE is considered {\em callee save}
for the purposes of the ABI. That is, if {\tt function1} calls 
{\tt function2}, then {\tt function2} is responsible for saving to the
stack any $\CPR$ registers it needs, and poping them off before returning.

Registers which are pushed to the stack in standard or transpose
way must be popped back using the same mode they were stored with.

The $\CPR$ registers $0..4$ are considered as function arguments
and/or return values. Due to the standard / transpose addressing modes, this
means that registers $16..19$  (which alias $0..4$ as per table \ref{tab:state-addr}) are also considered function arguments and/or return values. It is the
programmer's responsibility to correctly interpret results as being in
transposed or standard form.

All other $\CPR$ registers are considered temporaries.

\subsection{Instructions}

All instructions occupy the \encspace encoding space of the RISC-V opcode
map, using the associated \encopcode prefix for bits $6:0$ of each 
instruction.

\subsubsection{Move Instructions}
\paragraph{MVCOP}

Move a $\CPR$ register to a $\GPR$ register.

\begin{itemize}
\item \INST{MVCOP gpr, cpr}{
    $\GPR[*][\OPER{gpr}] \ASN \CPR[*][\OPER{cpr}]$
}
\end{itemize}


\paragraph{MVGPR[.t]}

The complement of \ASM{MVCOP}.
Move a $\GPR$ register to a $\CPR$ register.

\begin{itemize}
\item \INST{MVGPR cpr, gpr}{
    $\CPR[*][\OPER{cpr}] \ASN \GPR[*][\OPER{gpr}]$
}
\end{itemize}

\subsubsection{Packed Arithmetic}
\paragraph{ADD.px}

The instruction \ASM{ADD.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and adds corresponding fields together
ignoring any carry bits.

No overflow conditions are tested for, and \ASM{ADD.px} raises no exceptons.

\begin{itemize}
\item \INST{ADD.p8, rd, rs1, rs2}{
$\CPR[*][rd][ 3: 0] \ASN \CPR[*][rs1][ 3: 0] + \CPR[*][rs2][ 3: 0]$\\
$\CPR[*][rd][ 7: 4] \ASN \CPR[*][rs1][ 7: 4] + \CPR[*][rs2][ 7: 4]$\\
$\CPR[*][rd][11: 8] \ASN \CPR[*][rs1][11: 8] + \CPR[*][rs2][11: 8]$\\
$\CPR[*][rd][15:12] \ASN \CPR[*][rs1][15:12] + \CPR[*][rs2][15:12]$\\
$\CPR[*][rd][19:16] \ASN \CPR[*][rs1][19:16] + \CPR[*][rs2][19:16]$\\
$\CPR[*][rd][23:20] \ASN \CPR[*][rs1][23:20] + \CPR[*][rs2][23:20]$\\
$\CPR[*][rd][25:24] \ASN \CPR[*][rs1][25:24] + \CPR[*][rs2][25:24]$\\
$\CPR[*][rd][31:26] \ASN \CPR[*][rs1][31:26] + \CPR[*][rs2][31:26]$\\
}
\item \INST{ADD.p4, rd, rs1, rs2}{
$\CPR[*][rd][ 7: 0] \ASN \CPR[*][rs1][ 7: 0] + \CPR[*][rs2][ 7: 0]$\\
$\CPR[*][rd][15: 8] \ASN \CPR[*][rs1][15: 8] + \CPR[*][rs2][15: 8]$\\
$\CPR[*][rd][23:16] \ASN \CPR[*][rs1][23:16] + \CPR[*][rs2][23:16]$\\
$\CPR[*][rd][31:24] \ASN \CPR[*][rs1][31:24] + \CPR[*][rs2][31:24]$\\
}
\item \INST{ADD.p2, rd, rs1, rs2}{
$\CPR[*][rd][15: 0] \ASN \CPR[*][rs1][15: 0] + \CPR[*][rs2][15: 0]$\\
$\CPR[*][rd][31:16] \ASN \CPR[*][rs1][31:16] + \CPR[*][rs2][31:16]$\\
}
\item \INST{ADD.p1, rd, rs1, rs2}{
$\CPR[*][rd] \ASN \CPR[*][rs1] + \CPR[*][rs2]$\\
}
\end{itemize}

\paragraph{SUB.px}

The instruction \ASM{SUB.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and subtracts the {\tt rs2} fields from
the corresponding {\tt rs1} fields.

No overflow conditions are tested for, and \ASM{SUB.px} raises no exceptons.

\paragraph{MUL.px}

The instruction \ASM{MUL.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and multiplies the {\tt rs2} fields by
the corresponding {\tt rs1} fields.

No overflow conditions are tested for, and \ASM{MUL.px} raises no exceptons.

\paragraph{SLL.px}

The instruction \ASM{SLL.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and shifts the {\tt rs1} fields left
by the value in {\tt SHAMT}.

If the distance to shift by is greater than or equal to the size of each
packed field, then the result of the \ASM{SLL.px} instruction is
{\em implementation dependent}.

\paragraph{SRL.px}

The instruction \ASM{SRL.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and shifts the {\tt rs1} fields right
by the value in {\tt SHAMT}.

If the distance to shift by is greater than or equal to the size of each
packed field, then the result of the \ASM{SRL.px} instruction is
{\em implementation dependent}.

\paragraph{ROT.px}

The instruction \ASM{ROT.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and rotates the {\tt rs2} fields by
the value in {\tt SHAMT}.

\subsubsection{Bitwise and Twiddle Instructions}

\paragraph{XORT, ANDT, ORT}

The \ASM{XORT}, \ASM{ANDT}, and \ASM{ORT} instructions compute the
appropriate bitwise result of their operation between the {\tt rs1} and
{\tt rs2} operands. The result is then written into {\tt rd}.
\designnote{Originally the bitwise instructions were to have twiddle
functionality built-in, removing the need for a dedicated twiddle instruction.
The encoding space required however did not fit well with the existing RISC-V
register address and function field layout, and was extremely expensive.}

The difference between these instructions and their standard RISC-V
counterparts is that they operate on the $\CPR$ register file, and so
support the transposed addressing modes.

\begin{itemize}
\item \INST{XORT rd, rs1, rs2}{
    $ \CPR[*][\OPER{rd}] \ASN \CPR[*][rs1] \XOR \CPR[*][rs2] $ \\
}
\item \INST{ANDT rd, rs1, rs2}{
    $ \CPR[*][\OPER{rd}] \ASN \CPR[*][rs1] \AND \CPR[*][rs2] $ \\
}
\item \INST{ORT rd, rs1, rs2}{
    $ \CPR[*][\OPER{rd}] \ASN \CPR[*][rs1] \IOR \CPR[*][rs2] $ \\
}
\end{itemize}

Note that by having {\tt rs1} the same as {\tt rs2}, the twiddle
arithmetic instructions can be used to arbitrarily re-arrange bytes
within words. They can also be used to duplicate bytes within words.

\paragraph{TWID}

The \ASM{TWID} instruction is used to {\em twiddle} bytes within words.
It arbitrarily maps the bytes of a source word onto the bytes of a
destination word.

\begin{itemize}
\item \INST{TWID rd, rs1, b0, b1, b2, b3}{
    $ \CPR[*][\OPER{rd}][0] \ASN \CPR[*][\OPER{rs1}][\OPER{b0}] $ \\
    $ \CPR[*][\OPER{rd}][1] \ASN \CPR[*][\OPER{rs1}][\OPER{b1}] $ \\
    $ \CPR[*][\OPER{rd}][2] \ASN \CPR[*][\OPER{rs1}][\OPER{b2}] $ \\
    $ \CPR[*][\OPER{rd}][3] \ASN \CPR[*][\OPER{rs1}][\OPER{b3}] $ 
}
\end{itemize}


\subsubsection{Multi-precision Arithmetic}
\paragraph{ADD.m}
\paragraph{SUB.m}
\paragraph{ACC.m}
\paragraph{MAC.m}
\paragraph{SLL.m}
\paragraph{SRL.m}
\paragraph{EQU.m}
\paragraph{LTU.m}
\paragraph{GTU.m}

\subsubsection{Memory Access}

\paragraph{LBU.cr, LHU.cr, LW.cr}

The \ASM{LBU.cr}, \ASM{LHU.cr} and \ASM{LW.cr} instructions are analogous to
the standard RISC-V varients but with the following differences:

\begin{itemize}
\item They support transposition in their destination $\CPR$ register.
\item The halfword and byte varients can specify which halfword or byte of
      the destination register they are targeting.
\item The base address is taken from the normal RISC-V $\GPR$ set, while the
      target register is always in the $\CPR$ set.
\end{itemize}

These instructions will raise a {\em load address misaligned} instruction
if: the final source address is not aligned to the data type the instruction
is loading {\em and} the implementation does not support misaligned accesses.
The general rule here is that the \ASM{L*.cr} instructions should behave in
the same way as their RISC-V cousins in terms of exception handling,
interrupt behaviour and atomicity rules.

\begin{itemize}
\item \INST{LBU.cr  rd, b, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\CPR[*][rd][b] \ASN \MEM[*][addr]$
}
\item \INST{LHU.cr  rd, h, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $b_1 \ASN  (2'00_2 \IOR h) \LSH 1$ \\
    $b_2 \ASN  b_1 \IOR 1'1_2$ \\
    $\CPR[*][rd][b_2] \ASN \MEM[*][addr + 1]$ \\
    $\CPR[*][rd][b_1] \ASN \MEM[*][addr + 0]$
}
\item \INST{LW.cr  rd, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\CPR[*][rd][rb + 3] \ASN \MEM[*][addr+3]$ \\
    $\CPR[*][rd][rb + 2] \ASN \MEM[*][addr+2]$ \\
    $\CPR[*][rd][rb + 1] \ASN \MEM[*][addr+1]$ \\
    $\CPR[*][rd][rb + 0] \ASN \MEM[*][addr+0]$
}
\end{itemize}

\note{
    The notation above assumes a byte addressed memory, where {\tt db}
    is a two bit byte address and {\tt dh} is a one bit halfword address.
}

\paragraph{SB.cr, SH.cr, SW.cr}

The \ASM{SB.cr}, \ASM{SH.cr} and \ASM{SW.cr} instructions are analogous to
the standard RISC-V varients but with the following differences:

\begin{itemize}
\item They support transposition in their source data $\CPR$ register.
\item The halfword and byte varients can specify which halfword or byte of
      the source register they store.
\item The base address is taken from the normal RISC-V $\GPR$ set, while the
      source data register is always in the $\CPR$ set.
\end{itemize}

These instructions will raise a {\em store address misaligned} instruction
if: the final source address is not aligned to the data type the instruction
is storing {\em and} the implementation does not support misaligned accesses.
The general rule here is that the \ASM{L*.cr} instructions should behave in
the same way as their RISC-V cousins in terms of exception handling,
interrupt behaviour and atomicity rules.

\begin{itemize}
\item \INST{SB.cr  rs1, b, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
     $\MEM[*][addr] \ASN \CPR[*][rs2][b]$
}
\item \INST{SH.cr  rs1, h, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $b_1 \ASN  (2'00_2 \IOR h) \LSH 1$ \\
    $b_2 \ASN  b_1 \IOR 1'1_2$ \\
    $\MEM[*][addr + 1] \ASN \CPR[*][rs2][b_2]$ \\
    $\MEM[*][addr + 0] \ASN \CPR[*][rs2][b_1]$
}
\item \INST{SW.cr  rs1, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\MEM[*][addr+3] \ASN \CPR[*][rd][rb + 3]$ \\
    $\MEM[*][addr+2] \ASN \CPR[*][rd][rb + 2]$ \\
    $\MEM[*][addr+1] \ASN \CPR[*][rd][rb + 1]$ \\
    $\MEM[*][addr+0] \ASN \CPR[*][rd][rb + 0]$
}
\end{itemize}

\note{
    The notation above assumes a byte addressed memory, where {\tt b}
    is a two bit byte address and {\tt h} is a one bit halfword address.
}

\paragraph{SCATTER[.t]}
\paragraph{GATHER[.t]}


\newpage
\subsection{Instruction Listings}

This section lists the assembly notation for the instructions, as well as
their encodings.

\subsubsection{Listing}

{\tt
ADD.p1  rd, rs1, rs2 \quad\quad\quad MVCOP   rd, rs1                 \\
ADD.p2  rd, rs1, rs2 \quad\quad\quad MVGPR   rd, rs1                 \\
ADD.p4  rd, rs1, rs2 \quad\quad\quad XORT    rd, rs1, rs2            \\
ADD.p8  rd, rs1, rs2 \quad\quad\quad ANDT    rd, rs1, rs2            \\
SUB.p1  rd, rs1, rs2 \quad\quad\quad ORT     rd, rs1, rs2            \\
SUB.p2  rd, rs1, rs2 \quad\quad\quad TWID    rd, rs1, b0, b1, b2, b3 \\
SUB.p4  rd, rs1, rs2 \quad\quad\quad ADD.m   TBD                     \\
SUB.p8  rd, rs1, rs2 \quad\quad\quad SUB.m   TBD                     \\
MUL.p1  rd, rs1, rs2 \quad\quad\quad ACC.m   TBD                     \\
MUL.p2  rd, rs1, rs2 \quad\quad\quad MAC.m   TBD                     \\
MUL.p4  rd, rs1, rs2 \quad\quad\quad SLL.m   TBD                     \\
MUL.p8  rd, rs1, rs2 \quad\quad\quad SRL.m   TBD                     \\
SLL.p1  rd, rs1, rs2 \quad\quad\quad EQU.m   TBD                     \\
SLL.p2  rd, rs1, rs2 \quad\quad\quad LTU.m   TBD                     \\
SLL.p4  rd, rs1, rs2 \quad\quad\quad GTU.m   TBD                     \\
SLL.p8  rd, rs1, rs2 \quad\quad\quad LBU.cr  rd, imm(rs1)            \\
SRL.p1  rd, rs1, rs2 \quad\quad\quad LHU.cr  rd, imm(rs1)            \\
SRL.p2  rd, rs1, rs2 \quad\quad\quad LW.cr   rd, imm(rs1)            \\
SRL.p4  rd, rs1, rs2 \quad\quad\quad SB.cr   rs2, imm(rs1)           \\
SRL.p8  rd, rs1, rs2 \quad\quad\quad SH.cr   rs2, imm(rs1)           \\
ROT.p1  rd, rs1, rs2 \quad\quad\quad SW.cr   rs2, imm(rs1)           \\
ROT.p2  rd, rs1, rs2 \quad\quad\quad SCATTER TBD                     \\
ROT.p4  rd, rs1, rs2 \quad\quad\quad GATHER  TBD                     \\
ROT.p8  rd, rs1, rs2 \quad\quad\quad 
}

\subsubsection{Encoding}

The following standard RISC-V instruction encoding types are used in this
ISE:

\begin{center}
\begin{bytefield}[endianness=big]{32}
\bitheader{0-31}               \\
  \BB{7}{func7}
& \BB{5}{rs2  }
& \BB{5}{rs1  }
& \BB{3}{func3}
& \BB{5}{rd   }
& \BB{8}{opcode}
& \BB{8}{R-type} \\

  \BB{12}{imm[11:0]}
& \BB{5}{rs1  }
& \BB{3}{func3}
& \BB{5}{rd   }
& \BB{8}{opcode}
& \BB{8}{I-type} \\
  
  \BB{7}{imm[11:5]}
& \BB{5}{rs1  }
& \BB{5}{rs2  }
& \BB{3}{func3}
& \BB{5}{imm[4:0]}
& \BB{8}{opcode}
& \BB{8}{S-type} \\
\end{bytefield}
\end{center}

The table below shows the encodings for all instructions in the ISE

\begin{center}
\begin{bytefield}[endianness=big]{32}
\bitheader{0-31}               \\
\BH{7}{func7}& \BH{5}{rs2  }& \BH{5}{rs1  }& \BH{3}{func3}& \BH{5}{rd   }& \BH{8}{opcode}& \BH{8}{R-type} \\
\BB{7}{ 0000000 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ADD.p1 } \\
\BB{7}{ 0000001 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ADD.p2 } \\
\BB{7}{ 0000010 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ADD.p4 } \\
\BB{7}{ 0000011 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ADD.p8 } \\
\BB{7}{ 0000100 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SUB.p1 } \\
\BB{7}{ 0000101 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SUB.p2 } \\
\BB{7}{ 0000110 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SUB.p4 } \\
\BB{7}{ 0000111 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SUB.p8 } \\
\BB{7}{ 0001000 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ MUL.p1 } \\
\BB{7}{ 0001001 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ MUL.p2 } \\
\BB{7}{ 0001010 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ MUL.p4 } \\
\BB{7}{ 0001011 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ MUL.p8 } \\
\BB{7}{ 0001100 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SLL.p1 } \\
\BB{7}{ 0001101 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SLL.p2 } \\
\BB{7}{ 0001110 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SLL.p4 } \\
\BB{7}{ 0001111 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SLL.p8 } \\
\BB{7}{ 0010000 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SRL.p1 } \\
\BB{7}{ 0010001 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SRL.p2 } \\
\BB{7}{ 0010010 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SRL.p4 } \\
\BB{7}{ 0010011 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ SRL.p8 } \\
\BB{7}{ 0010100 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ROT.p1 } \\
\BB{7}{ 0010101 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ROT.p2 } \\
\BB{7}{ 0010110 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ROT.p4 } \\
\BB{7}{ 0010111 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ROT.p8 } \\
\BB{7}{ 0011000 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ XORT   } \\
\BB{7}{ 0011001 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ANDT   } \\
\BB{7}{ 0011010 }& \BB{5}{ rs2 }& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ ORT    } \\
\BB{7}{ 0011011 }& \BB{5}{00001}& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ MVCOP  } \\
\BB{7}{ 0011011 }& \BB{5}{00010}& \BB{5}{rs1}& \BB{3}{ 000 }& \BB{5}{rd}& \BB{8}{\encopcode}& \BB{8}{ MVGPR  } \\
\end{bytefield}

\begin{bytefield}[endianness=big]{32}
\bitheader{0-31}               \\
\BH{12}{imm[11:0]}& \BH{5}{rs1  }& \BH{3}{func3}& \BH{5}{rd   }& \BH{8}{opcode}& \BH{8}{I-type} \\
\BB{12}{imm[11:0]}& \BB{5}{rs1  }& \BB{3}{ 100 }& \BB{5}{rd   }& \BB{8}{\encopcode}& \BB{8}{LBU.cr} \\
\BB{12}{imm[11:0]}& \BB{5}{rs1  }& \BB{3}{ 101 }& \BB{5}{rd   }& \BB{8}{\encopcode}& \BB{8}{LHU.cr} \\
\BB{12}{imm[11:0]}& \BB{5}{rs1  }& \BB{3}{ 110 }& \BB{5}{rd   }& \BB{8}{\encopcode}& \BB{8}{LW.cr } \\

\BB{4}{0000}& 
\BB{2}{b0}&
\BB{2}{b1}&
\BB{2}{b2}&
\BB{2}{b3}&
\BB{5}{rs1  }& \BB{3}{ 111 }& \BB{5}{rd   }& \BB{8}{\encopcode}& \BB{8}{TWID  } \\
\end{bytefield}
  
\begin{bytefield}[endianness=big]{32}
\bitheader{0-31}               \\
\BH{7}{imm[11:5]}& \BH{5}{rs1  }& \BH{5}{rs2  }& \BH{3}{func3}& \BH{5}{imm[4:0]}& \BH{8}{opcode}& \BH{8}{S-type} \\
\BB{7}{imm[11:5]}& \BB{5}{rs1  }& \BB{5}{rs2  }& \BB{3}{ 001 }& \BB{5}{imm[4:0]}& \BB{8}{\encopcode}& \BB{8}{SB.cr} \\
\BB{7}{imm[11:5]}& \BB{5}{rs1  }& \BB{5}{rs2  }& \BB{3}{ 010 }& \BB{5}{imm[4:0]}& \BB{8}{\encopcode}& \BB{8}{SH.cr} \\
\BB{7}{imm[11:5]}& \BB{5}{rs1  }& \BB{5}{rs2  }& \BB{3}{ 011 }& \BB{5}{imm[4:0]}& \BB{8}{\encopcode}& \BB{8}{SW.cr} \\
\end{bytefield}
\end{center}
