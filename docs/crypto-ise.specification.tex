
This section specifies the ISE in terms of it's state and the instructions
which operate on that state.

\subsection{Notation}

Lorem ipsum doler set amet.


\subsection{State}

The ISE introduces an additional $16$ by $32$-bit register file which
is used exclusively by the instructions in this ISE. It is to the
crypto ISE what the floating-point register file is to the RISC-V
F extension.

The addressing is shown diagrammatically in table \ref{tab:state-addr}.

\begin{table}[h!]
\centering
\begin{tabular}{|l|l l l l|}
\hline
\multicolumn{1}{|l|}{3:0} & \textbf{31:24} & \textbf{23:16} & \textbf{15:8} & \textbf{7:0} \\ \hline
\textbf{0 }   & r0.3       & r0.2       & r0.1       & r0.0       \\ \hline
\textbf{1 }   & r1.3       & r1.2       & r1.1       & r1.0       \\ \hline
\textbf{2 }   & r2.3       & r2.2       & r2.1       & r2.0       \\ \hline
\textbf{3 }   & r3.3       & r3.2       & r3.1       & r3.0       \\ \hline
\textbf{4 }   & r4.3       & r4.2       & r4.1       & r4.0       \\ \hline
\textbf{5 }   & r5.3       & r5.2       & r5.1       & r5.0       \\ \hline
\textbf{6 }   & r6.3       & r6.2       & r6.1       & r6.0       \\ \hline
\textbf{7 }   & r7.3       & r7.2       & r7.1       & r7.0       \\ \hline
\textbf{8 }   & r8.3       & r8.2       & r8.1       & r8.0       \\ \hline
\textbf{9 }   & r9.3       & r9.2       & r9.1       & r9.0       \\ \hline
\textbf{10}   & r10.3      & r10.2      & r10.1      & r10.0      \\ \hline
\textbf{11}   & r11.3      & r11.2      & r11.1      & r11.0      \\ \hline
\textbf{12}   & r12.3      & r12.2      & r12.1      & r12.0      \\ \hline
\textbf{13}   & r13.3      & r13.2      & r13.1      & r13.0      \\ \hline
\textbf{14}   & r14.3      & r14.2      & r14.1      & r14.0      \\ \hline
\textbf{15}   & r15.3      & r15.2      & r15.1      & r15.0      \\ \hline
\end{tabular}
\caption{This table shows the per-byte layout of the register file. Note
that there is no {\em zero} register in the ISE. The register with
address $0$ will preserve writes.}
\label{tab:state-addr}
\end{table}

Unlike the RISC-V $\GPR$s, the zeroth $\CPR$ is not tied to zero.

\note{
A smart programmer will remember to clear their $\CPR$s of any secret data
before returning execution to some part of the system they did not write.
}

The number of general purpose registers to put into any ISA and ISE is
always contentious. We chose 16 general purpose registers for this ISE
for the following reasons:
\begin{itemize}
\item As demonstrated by ARM, 16 GPRs is plenty for most computation. Indeed
ARM actually has fewer GPRs due to the special nature of some of their
{\em high} registers. We believe mirroring the base RISC-V ISA and having
32 GPRs would have been overkill for an ISE such as this, even when the
{\tt F} extension adds 32 registers itself.
\item In area-optimised implementations such as micro-controllers, the
total area of a core is often dominated by the register-file. For embedded
applications which do not need all 32 GPRs, one could use the {\tt E}
extension, and use the area saved by having 16 GPRs to make room on the die
for the crypto ISE.
\item Fewer registers frees up instruction encoding space which would
normally have been needed for register addresses.
\end{itemize}

\subsubsection{ABI Standards}

All of the state added in the Crypto ISE is considered {\em callee save}
for the purposes of the ABI. That is, if {\tt function1} calls 
{\tt function2}, then {\tt function2} is responsible for saving to the
stack any $\CPR$ registers it needs, and popping them off before returning.

The $\CPR$ registers $0..4$ are considered as function arguments
and/or return values. 
All other $\CPR$ registers are considered temporaries.

\subsection{Instructions}

All instructions occupy the \encspace encoding space of the RISC-V opcode
map, using the associated \encopcode prefix for bits $6:0$ of each 
instruction.

\subsubsection{Move Instructions}
\paragraph{MV2GPR}

Move a $\CPR$ register to a $\GPR$ register.

\begin{itemize}
\item \INST{MV2GPR gpr, cpr}{
    $\GPR[*][\OPER{gpr}] \ASN \CPR[*][\OPER{cpr}]$
}
\end{itemize}


\paragraph{MV2COP}

The complement of \ASM{MV2GPR}.
Move a $\GPR$ register to a $\CPR$ register.

\begin{itemize}
\item \INST{MV2COP cpr, gpr}{
    $\CPR[*][\OPER{cpr}] \ASN \GPR[*][\OPER{gpr}]$
}
\end{itemize}

\subsubsection{Packed Arithmetic}

The packed arithmetic instructions are designed to provide scalable, sub-word
packed operations on multiple independent values. They operate on words, and
chunk them into 1, 2, 4, 8, or 16 separate values as shown in the table
below.

These instructions are designed to allow fast and efficient implementations
of the highly data parallel operations found in cryptographic block ciphers.

The general operation of each instruction is shown below, with $f(x,y)$
used to represent the specific functionality of each instruction.

\medskip

\begin{algorithm}[H]
    \KwIn{rs1, rs2 - Source registers 1 and 2}
    \KwIn{rd - destination register}
    \KwIn{pw - Pack width, the bit width of each operation}
    $b   \ASN 0 $\;
\While {$b < {\bf W}$}{
$\CPR[*][rd][b+pw:b] \ASN f(\CPR[*][rs1][b+pw:b],\CPR[*][rs2][b+pw:b])$\;
$b \ASN b + pw$\;
    }
\caption{Algorithm for performing packed arithmetic on words in the 
$\CPR$ register file. Here, ${\bf W}$ is the word-width in bits of the
registers, assumed to be $32$. For example, if $pw$ is 32, then the loop
will execute once, applying the function to the full 32-bit word. If $pw$
were $8$, then the function would be applied $8$ times, once to each
corresponding pair of nibbles in each word.}
\end{algorithm}

When coding these instructions as assembly mnemonics, the {\tt x} in the
instruction names below should be replaced with the pack width. Hence
for pack width 4, \ASM{SLLI.px} becomes \ASM{SLL.p4}.

\paragraph{ADD.px}

The instruction \ASM{ADD.px} treats the source and destination registers as
1,2,4,8 or 16 unsigned packed fields, and adds corresponding fields
together ignoring any carry bits.

No overflow conditions are tested for, and \ASM{ADD.px} raises no exceptions.

\paragraph{SUB.px}

The instruction \ASM{SUB.px} treats the source and destination registers as
1,2,4,8 or 16 unsigned, packed fields, and subtracts the {\tt rs2} fields
from the corresponding {\tt rs1} fields.

No overflow conditions are tested for, and \ASM{SUB.px} raises no exceptions.

\paragraph{MUL.px}

The instruction \ASM{MUL.px} treats the source and destination registers as
1,2,4,8 or 16 unsigned, packed fields, and multiplies the {\tt rs2} fields
by the corresponding {\tt rs1} fields.

No overflow conditions are tested for, and \ASM{MUL.px} raises no exceptions.

\paragraph{SLL[I].px}

The instruction \ASM{SLL[I].px} treats the source and destination registers as
1,2,4,8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
left by the value in {\tt SHAMT} (for \ASM{SLLI.px}) or {\tt rs2} 
(for \ASM{SLL.px}).

If the distance to shift by is greater than or equal to the size of each
packed field, then the result of the \ASM{SLL[I].px} instruction is
{\em implementation dependent}.

\paragraph{SRL[I].px}

The instruction \ASM{SRL[I].px} treats the source and destination registers as
1,2,4,8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
right by the value in {\tt SHAMT} (for \ASM{SRLI.px}) or {\tt rs2} 
(for \ASM{SRL.px}).

If the distance to shift by is greater than or equal to the size of each
packed field, then the result of the \ASM{SRL[I].px} instruction is
{\em implementation dependent}.

\paragraph{ROT[I].px}

The instruction \ASM{ROT[I].px} treats the source and destination registers as
1,2,4,8 or 16 unsigned, packed fields, and rotates the {\tt rs1} fields
left by the value in {\tt SHAMT} (for \ASM{ROTI.px}) or {\tt rs2} 
(for \ASM{ROT.px}).

\subsubsection{Packed Field Manipulation}


\paragraph{TWID.B, TWID.Hx, TWID.Cx}

These instructions allow permutation of different packed field widths.

The \ASM{TWID.B} instruction is used to {\em twiddle} bytes within words.
It arbitrarily maps the bytes of a source word onto the bytes of a
destination word.

The \ASM{TWID.[Hx]} instruction is used to {\em twiddle} nibbles within
the high or low half-words of a word respectively.
It works on the {\tt x}'th halfword of a register word where
$x\in{0,1}.$.

The \ASM{TWID.[Cx]} instruction is used to {\em twiddle} pairs of bits
\footnote{A {\em crumb}, if you will.}
within a byte. It works on the {\tt x}'th byte of a register word where
$x\in{0,1,2,3}.$.

\begin{itemize}
\item \INST{TWID.B rd, rs1, b0, b1, b2, b3}{
    $ \CPR[*][\OPER{rd}][0] \ASN \CPR[*][\OPER{rs1}][\OPER{b0}] $ \\
    $ \CPR[*][\OPER{rd}][1] \ASN \CPR[*][\OPER{rs1}][\OPER{b1}] $ \\
    $ \CPR[*][\OPER{rd}][2] \ASN \CPR[*][\OPER{rs1}][\OPER{b2}] $ \\
    $ \CPR[*][\OPER{rd}][3] \ASN \CPR[*][\OPER{rs1}][\OPER{b3}] $ 
}
\item \INST{TWID.H0 rd, rs1, n0, n1, n2, n3}{
    $ nibbles \ASN \TUPLE{\CPR[*][\OPER{rd}] [15:12],
                          \CPR[*][\OPER{rd}] [11: 8],
                          \CPR[*][\OPER{rd}] [ 7: 4],
                          \CPR[*][\OPER{rd}] [ 3: 0]} $ \\
    $ \CPR[*][\OPER{rd}] [ 3: 0] \ASN nibbles[\OPER{n0}] $ \\
    $ \CPR[*][\OPER{rd}] [ 7: 4] \ASN nibbles[\OPER{n1}] $ \\
    $ \CPR[*][\OPER{rd}] [11: 8] \ASN nibbles[\OPER{n2}] $ \\
    $ \CPR[*][\OPER{rd}] [15:12] \ASN nibbles[\OPER{n3}] $ \\
    $ \CPR[*][\OPER{rd}] [31:16] \ASN \CPR[*][\OPER{rs1}] [31:16] $
}
\item \INST{TWID.H1 rd, rs1, n0, n1, n2, n3}{
    $ nibbles \ASN \TUPLE{\CPR[*][\OPER{rd}] [31:28],
                          \CPR[*][\OPER{rd}] [27:24],
                          \CPR[*][\OPER{rd}] [23:20],
                          \CPR[*][\OPER{rd}] [19:16]} $ \\
    $ \CPR[*][\OPER{rd}] [19:16] \ASN nibbles[\OPER{n0}] $ \\
    $ \CPR[*][\OPER{rd}] [23:20] \ASN nibbles[\OPER{n1}] $ \\
    $ \CPR[*][\OPER{rd}] [27:24] \ASN nibbles[\OPER{n2}] $ \\
    $ \CPR[*][\OPER{rd}] [31:28] \ASN nibbles[\OPER{n3}] $ \\
    $ \CPR[*][\OPER{rd}] [15: 0] \ASN \CPR[*][\OPER{rs1}] [15: 0] $
}
\item \fixme{TWID.Cx example}.
\end{itemize}

Twiddle can be used to broadcast and re-order bit-pairs, nibbles and
bytes within words.

\subsubsection{Bitwise Instructions}

These instructions are designed to operate on bits within words, or
create masks which make operating on bits within words easy.

\paragraph{LUI.cr, LLI.cr}

The \ASM{LUI.cr} instruction loads a 16 bit immediate into the
upper half of a $\CPR$ register.

The \ASM{LLI.cr} instruction bitwise loads a 16 bit immediate into the
lower half of a $\CPR$ register. 

\begin{itemize}
\item \INST{LUI.cr rd, imm16 }{
    $\CPR[*][\OPER{rd}][31:16] \ASN imm16$ \\
}
\item \INST{LLI.cr rd, imm16 }{
    $\CPR[*][\OPER{rd}][15: 0] \ASN imm16$ \\
}
\end{itemize}

These instructions are designed to be used for mask creation and constant
loading. The \ASM{LUI.cr} instruction mirrors the RISC-V counterpart, but
does not zero the lower half of the register.
\designnote{The RISC-V version of \ASM{LUI} is both for constant creation
(in tandem with \ASM{ORI} and loading addresses. Since the zeroing of
the low 12 bits by \ASM{LUI} is mainly useful for addresses, we remove
this functionality in favour of leaving the low half of the register
unmodified. The rationale being that two instructions can still create
and 32-bit immediate, but that if we know a register is zero to begin
with, we can then use only one instruction to create masks which fit
into only a single halfword.}


\instdesc{BOP.cr}

The \instref{BOP.cr} is designed to express all bitwise logic functions, and be
amenable to bit-sliced implementations of cryptographic functions.

\begin{itemize}
\item \INST{BOP.cr rd, rs1, rs2, lut4}{
    $\forall i \in \{0..31\}$
    $ \CPR[*][\OPER{rd}][i] \ASN $
    $ \OPER{lut4}[\CPR[*][rs1][i] \CONS \CPR[*][rs2][i]] $ \\
}
\end{itemize}

\instref{BOP.cr} takes a 4-bit immediate {\tt lut4}, and uses the concatenated
$i$'th bits of register inputs $\GPR[*][rs1]$ and  $\GPR[*][rs2]$
as the inputs, writing the output bit of the lut to the $i$'th bit of the
destination register.
\designnote{
    This instruction must be implemented with care, since a naive
    implementation will end up with a 32-port LUT, with correspondingly
    poor timing performance.
}

The following examples of \instref{BOP.cr} show how to encode the existing
bitwise operation instructions found in the base RISC-V architecture.

\begin{lstlisting}[style=float]
bop.cr  c1, c2, c3, 0001    // AND
bop.cr  c1, c2, c3, 0111    // OR 
bop.cr  c1, c2, c3, 0110    // XOR
\end{lstlisting}


\instdesc{MIX.cr}

The \instref{MIX.cr} instruction allows an arbitrary bit-wise mixing of two
register values, using a mask stored in a third register. It first rotates 
the source register value in {\tt rs1} by the ammount in shamt, and then mixes
the rotated value and the source value according to the mask value in
{\tt rs2}.

\ASM{LMIX.cr} will rotate the the value in {\tt rs1} to the right by $0..15$,
while \ASM{HMIX.cr} will rotate to the right by $16..31$. 
\designnote{This decision was made simply to make the encoding space
easier to manage. Rather than adding another 5-bit immediate field, it was
more efficient to re-use the 4-bit lut field of the \instref{BOP.cr}
instruction.}

\begin{itemize}
\item \INST{LMIX.cr rd, rs1, rs2,shamt}{
    $t_0 \ASN \CPR[*][rs1] \RRT shamt $\\
    $\forall i \in {0..31}$
    $    \CPR[*][rd][i] \ASN \CPR[*][rs2][i] ? t_0[i] : \CPR[*][rd][i]$
}
\item \INST{HMIX.cr rd, rs1, rs2,shamt}{
    $t_0 \ASN \CPR[*][rs1] \RRT (16 + shamt) $\\
    $\forall i \in {0..31}$
    $    \CPR[*][rd][i] \ASN \CPR[*][rs2][i] ? t_0[i] : \CPR[*][rd][i]$
}
\end{itemize}

\ASM{MIX.cr} allows us to create any mix of bits from two registers
using a single 3-instruction sequence:

\begin{lstlisting}[style=float]
LUI.cr   c0, 0xF0F0     // Load a mask into c0 which will select
LLI.cr   c0, 0xF0F0     // alternate nibbles from each register
LMIX.cr  c2, c1, c0, 0  // Odd nibbles from c1, even nibbles from c2.
LMIX.cr  c3, c1, c0, 4  // Even nibbles from c1, even nibbles from c3.
LMIX.cr  c4, c1, c0, 4  // Odd  nibbles from c1, even nibbles from c3.
\end{lstlisting}

We can also use it to create insert and deposit style instruction
sequences. \designnote{
    The rationale for rejecting actual bitfield insert/extract/deposit
    instructions was two fold. 1) These sorts of instructions are very
    expensive to encode if they are to be completely flexible. 
    2) Given that we already have a very capable set of 
    permutation instruction (\ASM{TWID.*}), and can speedily load
    large immediates (\ASM{LUI/LLI}), it was more efficient and
    flexible to add a more generic instruction which would
    complement their functionality and potentially be more flexible
    still. While it would be nice to have a completely orthogonal
    set of instructions for extracting/depositing each pack width,
    constraints on encoding space and instruction flexibility
    make it more expensive to implement than it is worth.
    Implementation wise, it is also easier to re-use existing
    rotate logic than the dedicated muxing logic needed by generic
    insert/extract/deposit instructions.
}

\begin{lstlisting}[style=float]
LUI.cr   c0, 0x0000     // Load a mask into c0 to select
LLI.cr   c0, 0x7800     // bits 10:7 from a register
LMIX.cr  c2, c1, c0, 8  // c2[10:7] <- c1[19:15]

LLI.cr   c0, 0x000E     // byte 0
HMIX.cr  c2, c1, c0, 0  // c2[7:1] <- c1[23:17]
\end{lstlisting}

\subsubsection{Multi-precision Arithmetic}

Public key cryptography relies heavily on modular arithmetic over very
large integers. The following instructions are designed to allow
operations over arbitrarily large integers, using software based carry
and overflow mechanisms. This mirrors how the base RISC-V ISA currently
supports carry and overflow.

These instructions use two destination registers and between three
and four source registers. Hence, some restrictions are placed on how
registers can be addressed.

\begin{itemize}
\item Destination registers are referred too as contiguous, even-odd
pairs. This means any two adjacently addressed registers, where the
first register address is even (zero being considered even for this
discussion) and the second address is one more than the first can be
used as the destination for a multi-precision instructions. \designnote{
    This scheme means the function to compute the actual source registers
    from the minimum 3-bit encoding is simply to append either {\tt 00}
    or {\tt 01} depending on the even or odd address respectively.
}

For example, $(0,1), (2,3)$ and $(10,11)$ are all valid
pairs of destination registers. $(5,6)$ is not valid because the first
is an odd number. $(6,5)$ is not valid because $6 > 5$. The pair $(6,9)$
is not valid because $6$ and $9$ are not adjacent.
\end{itemize}

\paragraph{ADD2.mp, ADD3.mp}

\begin{itemize}
\item \INST{ADD3.mp (rd2, rd1), rs1, rs2, rs3     }{
$t \ASN ( \CPR[*][\OPER{rs}_1] + \CPR[*][\OPER{rs}_2] ) + \CPR[*][\OPER{rs}_3] $\\
$\CPR[*][\OPER{rd}_1] \ASN t[31: 0]$\\
$\CPR[*][\OPER{rd}_2] \ASN t[64:32]$\\
}
\item \INST{ADD2.mp (rd2, rd1), rs1, rs2          }{
$t \ASN ( \CPR[*][\OPER{rs}_1] + \CPR[*][\OPER{rs}_2] ) $\\
$\CPR[*][\OPER{rd}_1] \ASN t[31: 0]$\\
$\CPR[*][\OPER{rd}_2] \ASN t[64:32]$\\
}
\end{itemize}

\paragraph{SUB2.mp, SUB3.mp}

\fixme{I'm not sure I understand this instruction. Why is rs3
subtracted from the sum of rs1 and rs2? - Ben}

\begin{itemize}
\item \INST{SUB3.mp (rd2, rd1), rs1, rs2, rs3     }{
$t \ASN ( \CPR[*][\OPER{rs}_1] \SOP{+}{u}     \CPR[*][\OPER{rs}_2] ) - \CPR[*][\OPER{rs}_3]$\\
$\CPR[*][\OPER{rd}_1] \ASN t_{1 \cdot \W - 1, \ldots,  0}$\\
$\CPR[*][\OPER{rd}_2] \ASN t_{        \W                }$\\
}
\item \INST{SUB2.mp (rd2, rd1), rs1, rs2          }{
$t \ASN ( \CPR[*][\OPER{rs}_1] -   \CPR[*][\OPER{rs}_2] ) $\\
$\CPR[*][\OPER{rd}_1] \ASN t_{1 \cdot \W - 1, \ldots,  0}$\\
$\CPR[*][\OPER{rd}_2] \ASN t_{        \W                }$\\
}
\end{itemize}

\paragraph{ACC2.mp, ACC1.mp}

\begin{itemize}
\item \INST{ACC2.mp (rd2, rd1), rs1, rs2}{
$t \ASN ( \CPR[*][\OPER{rd}_2] \CONS \CPR[*][\OPER{rd}_1] ) + \CPR[*][\OPER{rs}_1] + \CPR[*][\OPER{rs}_2] $\\
$\CPR[*][\OPER{rd}_1] \ASN t_{1 \cdot \W - 1, \ldots,  0} $\\
$\CPR[*][\OPER{rd}_2] \ASN t_{2 \cdot \W - 1, \ldots, \W} $\\
}
\item \INST{ACC1.mp (rd2, rd1), rs1}{
$t \ASN ( \CPR[*][\OPER{rd}_2] \CONS \CPR[*][\OPER{rd}_1] ) + \CPR[*][\OPER{rs}_1]$\\
$\CPR[*][\OPER{rd}_1] \ASN t_{1 \cdot \W - 1, \ldots,  0} $\\
$\CPR[*][\OPER{rd}_2] \ASN t_{2 \cdot \W - 1, \ldots, \W} $\\
}
\end{itemize}

\paragraph{MAC.mp}

\begin{itemize}
\item \INST{MAC.mp (rd1, rd2), rs1, rs2, rs3}{
$t \ASN ( \CPR[*][\OPER{rs}_1] \SOP{\cdot}{u} \CPR[*][\OPER{rs}_2] ) + \CPR[*][\OPER{rs}_3]$\\
$\CPR[*][\OPER{rd}_0] \ASN t_{1 \cdot \W - 1, \ldots,  0}$\\
$\CPR[*][\OPER{rd}_1] \ASN t_{2 \cdot \W - 1, \ldots, \W}$\\
}
\end{itemize}

\paragraph{SLLI.mp, SLLR.mp}

\begin{itemize}
\item \INST{SLLI.mp (rd2, rd1), rs1, rs2, shamt   }{
$t \ASN {\CPR[*][rs1] \CONS \CPR[*][rs2]} \LSH shamt$\\
$\CPR[*][rd2] \ASN t[63:32]$ \\
$\CPR[*][rd1] \ASN t[31:0]$
}
\item \INST{SLLR.mp (rd1, rd2), rs1, rs2, rs3     }{
$t \ASN {\CPR[*][rs1] \CONS \CPR[*][rs2]} \LSH \CPR[*][rs3][5:0]$\\
$\CPR[*][rd2] \ASN t[63:32]$ \\
$\CPR[*][rd1] \ASN t[31:0]$
}
\end{itemize}

\paragraph{SRLI.mp,SRL.mp}

\begin{itemize}
\item \INST{SRLI.mp (rd2, rd1), rs1, rs2, shamt   }{
$t \ASN {\CPR[*][rs1] \CONS \CPR[*][rs2]} \RSH shamt$\\
$\CPR[*][rd2] \ASN t[63:32]$ \\
$\CPR[*][rd1] \ASN t[31:0]$
}
\item \INST{SRLR.mp (rd1, rd2), rs1, rs2, rs3     }{
$t \ASN {\CPR[*][rs1] \CONS \CPR[*][rs2]} \RSH \CPR[*][rs3][5:0]$\\
$\CPR[*][rd2] \ASN t[63:32]$ \\
$\CPR[*][rd1] \ASN t[31:0]$
}
\end{itemize}

\paragraph{EQU.mp}

\begin{itemize}
\item \INST{EQU.mp rd1,      rs1, rs2, rs3     }{
$\GPR[*][\OPER{rd}_1] \ASN ( \CPR[*][\OPER{rs}_1] = \CPR[*][\OPER{rs}_2] ) \AND \CPR[*][\OPER{rs}_3]  $\\
}
\end{itemize}

\paragraph{LTU.mp}

\begin{itemize}
\item \INST{LTU.mp rd1,      rs1, rs2, rs3     }{
$\GPR[*][\OPER{rd}_1] \ASN ( \CPR[*][\OPER{rs}_1] < \CPR[*][\OPER{rs}_2] ) \IOR ( ( \CPR[*][\OPER{rs}_1] = \CPR[*][\OPER{rs}_2] ) \AND \CPR[*][\OPER{rs}_3] )$
}
\end{itemize}

\paragraph{GTU.mp}

\begin{itemize}
\item \INST{GTU.mp rd1,      rs1, rs2, rs3     }{
$\GPR[*][\OPER{rd}_1] \ASN ( \CPR[*][\OPER{rs}_1] > \CPR[*][\OPER{rs}_2] ) \IOR ( ( \CPR[*][\OPER{rs}_1] = \CPR[*][\OPER{rs}_2] ) \AND \CPR[*][\OPER{rs}_3] )$
}
\end{itemize}

\subsubsection{Memory Access}

The ISE contains several instructions listed below which allow memory
accesses to directly address the $\CPR$ register file. This means we do
not need to first load to the $\GPR$ register file, then move data into
the $\CPR$s.

All ISE memory access instructions source their base address from the
$\GPR$ register file, but read and write data in the $\CPR$s. This
prevents address manipulation needing to be done in the $\CPR$s.
\designnote{
There is no requirement for the ISE memory instructions to share the same
address space as the standard ISA. One may wish to completely separate
the physical memory used to store cryptographic secrets from the rest of
the virtual / logical memory space, and the ISE does not stop implementers
from doing so. This allows for hardware root-of-trust type devices to keep
their keys in tamper-proof memory, while still letting the rest of the
program exist in standard RAM/Flash.
}


\paragraph{LBU.cr, LHU.cr, LW.cr}

The \ASM{LBU.cr}, \ASM{LHU.cr} and \ASM{LW.cr} instructions are analogous to
the standard RISC-V variants but with the following differences:

\begin{itemize}
\item The halfword and byte variants can specify which halfword or byte of
      the destination register they are targeting.
\item There is no sign-extending equivalent of the \ASM{LH} and \ASM{LB}
      instructions.
\item The base address is taken from the normal RISC-V $\GPR$ set, while the
      target register is always in the $\CPR$ set.
\end{itemize}

These instructions will raise a {\em load address misaligned} exception
if: the final source address is not aligned to the data type the instruction
is loading {\em and} the implementation does not support misaligned accesses.
The general rule here is that the \ASM{L*.cr} instructions should behave in
the same way as their RISC-V cousins in terms of exception handling,
interrupt behaviour and atomicity rules.

\begin{itemize}
\item \INST{LBU.cr  rd, b, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\CPR[*][rd][b] \ASN \MEM[*][addr]$
}
\item \INST{LHU.cr  rd, h, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $b_1 \ASN  (2'00_2 \IOR h) \LSH 1$ \\
    $b_2 \ASN  b_1 \IOR 1'1_2$ \\
    $\CPR[*][rd][b_2] \ASN \MEM[*][addr + 1]$ \\
    $\CPR[*][rd][b_1] \ASN \MEM[*][addr + 0]$
}
\item \INST{LW.cr  rd, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\CPR[*][rd][rb + 3] \ASN \MEM[*][addr+3]$ \\
    $\CPR[*][rd][rb + 2] \ASN \MEM[*][addr+2]$ \\
    $\CPR[*][rd][rb + 1] \ASN \MEM[*][addr+1]$ \\
    $\CPR[*][rd][rb + 0] \ASN \MEM[*][addr+0]$
}
\end{itemize}

\note{
    The notation above assumes a byte addressed memory, where {\tt b}
    is a two bit byte address and {\tt h} is a one bit halfword address.
}

\paragraph{SB.cr, SH.cr, SW.cr}

The \ASM{SB.cr}, \ASM{SH.cr} and \ASM{SW.cr} instructions are analogous to
the standard RISC-V variants but with the following differences:

\begin{itemize}
\item The halfword and byte variants can specify which halfword or byte of
      the source register they store.
\item The base address is taken from the normal RISC-V $\GPR$ set, while the
      source data / destination register is always in the $\CPR$ set.
      \designnote{
        The decision to source the base address from the $\GPR$ set rather
        than a $\CPR$ was because all of the RISC-V address calculation
        instructions work perfectly well on the $\GPR$s and there is no sense
        in duplicating that functionality for this ISE. This free's up
        encoding space, and lets the $\CPR$ state be used for the compute
        work it was designed for rather than mundane address calculation.
        While care must be
        taken to avoid hazards between the different register sets, we
        believe this decision makes sense overall.
      }
\end{itemize}

These instructions will raise a {\em store address misaligned} exception
if: the final source address is not aligned to the data type the instruction
is storing {\em and} the implementation does not support misaligned accesses.
The general rule here is that the \ASM{L*.cr} instructions should behave in
the same way as their RISC-V cousins in terms of exception handling,
interrupt behaviour and atomicity rules.

\begin{itemize}
\item \INST{SB.cr  rs1, b, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
     $\MEM[*][addr] \ASN \CPR[*][rs2][b]$
}
\item \INST{SH.cr  rs1, h, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $b_1 \ASN  (2'00_2 \IOR h) \LSH 1$ \\
    $b_2 \ASN  b_1 \IOR 1'1_2$ \\
    $\MEM[*][addr + 1] \ASN \CPR[*][rs2][b_2]$ \\
    $\MEM[*][addr + 0] \ASN \CPR[*][rs2][b_1]$
}
\item \INST{SW.cr  rs1, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\MEM[*][addr+3] \ASN \CPR[*][rd][rb + 3]$ \\
    $\MEM[*][addr+2] \ASN \CPR[*][rd][rb + 2]$ \\
    $\MEM[*][addr+1] \ASN \CPR[*][rd][rb + 1]$ \\
    $\MEM[*][addr+0] \ASN \CPR[*][rd][rb + 0]$
}
\end{itemize}

\note{
    The notation above assumes a byte addressed memory, where {\tt b}
    is a two bit byte address and {\tt h} is a one bit halfword address.
}

\paragraph{SCATTER.[b,h], GATHER[.b,h]}

The \ASM{SCATTER} and \ASM{GATHER} instructions are designed to be used as
s-box lookup instructions. The {\tt .b} variants allow four separate lookups
per instruction into a 256 entry LUT stored in memory, while the {\tt .h}
variants allow two lookups into a 16-bit LUT stored in memory. \ASM{GATHER}
will move the looked-up values from memory into a register, while \ASM{SCATTER}
will move bytes of a register word back into the LUT in memory.
\designnote{
    While it is of-course possible to emulate the {\tt .h} variants of
    \ASM{SCATTER} and \ASM{GATHER} with the {\tt.b} variants, we felt that
    the performance and efficency savings to be had from telling the hardware
    explicitly to work on halfwords were worth the extra instructions.
}

The address $a_x$ of each byte/halfword to be loaded or stored is computed by
adding an offset $x$ from the {\tt offsets} $\CPR$ register, and adding it
to the $base$ $\GPR$ register. For the {\tt .b} variants, there are four
offsets each corresponding to the four bytes of the offsets source register
word. For the {\tt .h} variant, there are two offsets corresponding to the
upper and lower halfwords of the registers.

Both instructions use the $\GPR$s to source their base address, while the
offset indices into the LUT come from the $\CPR$ registers. This mirrors
how the ISE load and store instructions compute their addresses.

\bigskip

\begin{minipage}{0.5\textwidth}
\begin{itemize}
\item \INST{GATHER.b rd, base, offsets}{
    $ a_0 \ASN \GPR[*][base] + \CPR[*][offsets][ 7: 0]$ \\
    $ a_1 \ASN \GPR[*][base] + \CPR[*][offsets][15: 8]$ \\
    $ a_2 \ASN \GPR[*][base] + \CPR[*][offsets][23:16]$ \\
    $ a_3 \ASN \GPR[*][base] + \CPR[*][offsets][31:24]$ \\
    $\CPR[*][rd][0] \ASN \MEM[*][a_0]$ \\
    $\CPR[*][rd][1] \ASN \MEM[*][a_1]$ \\
    $\CPR[*][rd][2] \ASN \MEM[*][a_2]$ \\
    $\CPR[*][rd][3] \ASN \MEM[*][a_3]$
}
\item \INST{GATHER.h rd, base, offsets}{
    $ a_0 \ASN \GPR[*][base] + \CPR[*][offsets][15: 0]$ \\
    $ a_1 \ASN \GPR[*][base] + \CPR[*][offsets][31:16]$ \\
    $\CPR[*][rd][15: 0] \ASN \MEM[*][a_0 + 1] \CONS  \MEM[*][a_0]$ \\
    $\CPR[*][rd][31:16] \ASN \MEM[*][a_1 + 1] \CONS  \MEM[*][a_1]$
}
\end{itemize}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{itemize}
\item \INST{SCATTER.b rs, base, offsets}{
    $ a_0 \ASN \GPR[*][base] + \CPR[*][offsets][ 7: 0]$ \\
    $ a_1 \ASN \GPR[*][base] + \CPR[*][offsets][15: 8]$ \\
    $ a_2 \ASN \GPR[*][base] + \CPR[*][offsets][23:16]$ \\
    $ a_3 \ASN \GPR[*][base] + \CPR[*][offsets][31:24]$ \\
    $ \MEM[*][a_0] \ASN \CPR[*][rs][0]$ \\
    $ \MEM[*][a_1] \ASN \CPR[*][rs][1]$ \\
    $ \MEM[*][a_2] \ASN \CPR[*][rs][2]$ \\
    $ \MEM[*][a_3] \ASN \CPR[*][rs][3]$
}
\item \INST{SCATTER.h rs, base, offsets}{
    $ a_0 \ASN \GPR[*][base] + \CPR[*][offsets][15: 0]$ \\
    $ a_1 \ASN \GPR[*][base] + \CPR[*][offsets][31:16]$ \\
    $ \MEM[*][a_0 + 1] \CONS  \MEM[*][a_0] \ASN \CPR[*][rs][15: 0]$ \\
    $ \MEM[*][a_1 + 1] \CONS  \MEM[*][a_1] \ASN \CPR[*][rs][31:16]$
}
\end{itemize}
\end{minipage}

\bigskip

\note{
    The scatter instruction requires three register file reads.
    Because the reads are split across the $\GPR$ and $\CPR$ registers,
    no {\em extra} ports are needed on either register file beyond the
    standard two-read-one-write set.
}

An implementation may perform the memory accesses in any order. The instructions
will raise address misalignment exceptions in line with how misalignment is
handled in the rest of the ISA.

If any of the memory accesses cause
a {\em load access fault, load page fault, store page fault} or
{\em store access fault} then the address of the access which caused the
exception is written to the {\tt MTVAL} csr. The value taken by the
destination register bytes should an exception occur at any point in the
instruction is {\em implementation dependent}.

Implementations may abort execution of \ASM{SCATTER} or \ASM{GATHER} part way
though in order to service an interrupt. If the instructions are aborted
early, the value taken by the destination register bytes is {\em
implementation dependent}. The implementation is responsible for ensuring
that the {\tt EPC} register is set appropriately depending on whether the
interrupt is taken during, or at the end of, the instruction.
\designnote{Implementation of these instructions should consider the impact of
shared memory systems, since it will be possible for other agents in the
system to access memory during the execution of this instruction. In systems
possessing a cache, programmers must be mindful that these instructions
can cause odd behaviour due to the non-linear access pattern the instruction
creates.}

The rationale for these instructions is two fold. They help with code density,
since at-least four instructions worth of work can now be done
in one instruction. They can also help with energy efficiency, since fewer
instructions need to be fetched and travel through an execution pipeline in
order to achieve the same goal. They are not designed to enhance performance
(in terms of cycles to complete an operation), but this may be a side-effect
of some implementations.

\newpage
\subsection{Instruction Listings}

This section lists the assembly notation for the instructions, as well as
their encodings.

{\tt
MV2GPR      rd, rs1                 \\
MV2COP      rd, rs1                 \\
TWID.B      rd, rs1, b0, b1, b2, b3 \\
TWID.HN     rd, rs1, n0, n1, n2, n3 \\
TWID.LN     rd, rs1, n0, n1, n2, n3 \\
ADD.px      rd, rs1, rs2            \\
SUB.px      rd, rs1, rs2            \\
MUL.px      rd, rs1, rs2            \\
SLLI.px     rd, rs1, shamt          \\
SRLI.px     rd, rs1, shamt          \\
ROTI.px     rd, rs1, shamt          \\
SLL.px      rd, rs1, rs2            \\
SRL.px      rd, rs1, rs2            \\
ROT.px      rd, rs1, rs2            \\
XOR.cr      rd, rs1, rs2            \\
AND.cr      rd, rs1, rs2            \\
OR.cr       rd, rs1, rs2            \\
BOP.cr      rd, rs1, rs2, lut4      \\
ADD3.mp     (rd1, rd2),  rs1, rs2, rs3 \\
ADD2.mp     (rd1, rd2),  rs1, rs2  \\
SUB3.mp     (rd1, rd2),  rs1, rs2, rs3 \\
SUB2.mp     (rd1, rd2),  rs1, rs2  \\
ACC2.mp     (rd1, rd2),  rs1, rs2  \\
ACC1.mp     (rd1, rd2),  rs1       \\
MAC.mp      (rd1, rd2),  rs1, rs2, rs3 \\
MAA.mp      (rd1, rd2),  rs1, rs2, rs3, rs4 \\
SLLI.mp     (rd1, rd2),  rs1, rs2, shamt \\
SLLR.mp     (rd1, rd2),  rs1, rs2, rs3 \\
SRLI.mp     (rd1, rd2),  rs1, rs2, shamt \\
SRLR.mp     (rd1, rd2),  rs1, rs2, rs3 \\
EQU.mp      rd1,         rs1, rs2, rs3 \\
LTU.mp      rd1,         rs1, rs2, rs3 \\
GTU.mp      rd1,         rs1, rs2, rs3 \\
LBU.cr      rd , imm(rs1)           \\
LHU.cr      rd , imm(rs1)           \\
LW.cr       rd , imm(rs1)           \\
LUI.cr      rd,  imm16              \\
LLI.cr      rd,  imm16              \\
SB.cr       rs2, imm(rs1)           \\
SH.cr       rs2, imm(rs1)           \\
SW.cr       rs2, imm(rs1)           \\
SCATTER.b   rs, base, offsets       \\
GATHER.b    rd, base, offsets       \\
SCATTER.h   rs, base, offsets       \\
GATHER.h    rd, base, offsets       \\
}

\newpage
\subsection{Instruction Encodings}

The following tables show the encodings for all instructions in the ISE,
grouped by their layout.

\encodingsel{
    \note{The load/store byte/halfword instructions encode which bytes
    of the destination / source register they are accessing using the
    {\tt ca}, {\tt cc} and {\tt cd} bits.
    For the load instructions, {\tt cd} specifies the byte, and {\tt cc}
    specifies the halfword. For the store instructions {\tt ca}
    specifies the byte, and {\tt cc} also specifies the halfword.
}
}{ fig:encodings-else }


\encodingspx{
Packed register type instruction encodings. 
The fields {\tt ca, cb} and {\tt cc} are used by the {\tt *.px} instructions
to encode the pack width of their operations. The three bits are
concatenated into a 3-bit vector $a,b,c$ and then decoded into pack widths
using the following lookup table. \\
\begin{itemize}
\item $ca,cb,cc = 000 \Rightarrow $ Pack width $1$  $\Rightarrow$ 1 32-bit word
\item $ca,cb,cc = 001 \Rightarrow $ Pack width $2$  $\Rightarrow$ 2 halfwords
\item $ca,cb,cc = 010 \Rightarrow $ Pack width $4$  $\Rightarrow$ 4 bytes
\item $ca,cb,cc = 011 \Rightarrow $ Pack width $8$  $\Rightarrow$ 8 nibbles
\item $ca,cb,cc = 100 \Rightarrow $ Pack width $16$ $\Rightarrow$ 16 crumbs (2-bit values)
\item $ca,cb,cc = 101 $ - Reserved. Should be treated as an invalid opcode.
\item $ca,cb,cc = 110 $ - Reserved. Should be treated as an invalid opcode.
\item $ca,cb,cc = 111 $ - Reserved. Should be treated as an invalid opcode.
\end{itemize}
}{
fig:encodings-rtype
}


\encodingsmp{
Multi-precision integer instruction encodings. All instructions in
this class are identified first by the {\tt f3} field, then by the {\tt c}
field. The {\tt c} field splits comparison operations from compute operations.
The {\tt mo} and {\tt op} fields then further identify the instructions.
Note that the {\tt rd} field for the comparison instructions is a RISC-V
$\GPR$ register address.
}{
fig:encodings-mp
}
