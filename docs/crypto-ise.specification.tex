
This section specifies the ISE in terms of it's state and the instructions
which operate on that state.

\subsection{Notation}

Lorem ipsum doler set amet.


\subsection{State}

The ISE introduces an additional $16$ by $32$-bit register file. It can
be accessed in {\em standard} mode or {\em transposed} mode.

The addressing is shown diagramatically in table \ref{tab:state-addr}.

Because there are 32 RISC-V $\GPR$s and only 16 ISE $\CPR$s, the spare
register address bit in the ISE instruction encodings is used to determine
whether to access the register file in standard or transpose mode. In this
case, the {\em top} 16 register addresses access transpose mode, while the
{\em bottom} 16 register addresses access standard mode. \designnote{
    This introduces some complexities with regard to forwarding register
    values in a pipelined design, since one must identify on a per-byte
    basis whether a value must be forwarded, rather than on a per-word
    basis.
}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l l l l|}
\hline
\multicolumn{1}{|l|}{2:0} & \textbf{ } & \textbf{ } & \textbf{ } & \textbf{ } \\ \hline
\textbf{0 }   & r0.3       & r0.2       & r0.1       & r0.0       \\ \hline
\textbf{1 }   & r1.3       & r1.2       & r1.1       & r1.0       \\ \hline
\textbf{2 }   & r2.3       & r2.2       & r2.1       & r2.0       \\ \hline
\textbf{3 }   & r3.3       & r3.2       & r3.1       & r3.0       \\ \hline
\textbf{4 }   & r4.3       & r4.2       & r4.1       & r4.0       \\ \hline
\textbf{5 }   & r5.3       & r5.2       & r5.1       & r5.0       \\ \hline
\textbf{6 }   & r6.3       & r6.2       & r6.1       & r6.0       \\ \hline
\textbf{7 }   & r7.3       & r7.2       & r7.1       & r7.0       \\ \hline
\textbf{8 }   & r8.3       & r8.2       & r8.1       & r8.0       \\ \hline
\textbf{9 }   & r9.3       & r9.2       & r9.1       & r9.0       \\ \hline
\textbf{10}   & r10.3      & r10.2      & r10.1      & r10.0      \\ \hline
\textbf{11}   & r11.3      & r11.2      & r11.1      & r11.0      \\ \hline
\textbf{12}   & r12.3      & r12.2      & r12.1      & r12.0      \\ \hline
\textbf{13}   & r13.3      & r13.2      & r13.1      & r13.0      \\ \hline
\textbf{14}   & r14.3      & r14.2      & r14.1      & r14.0      \\ \hline
\textbf{15}   & r15.3      & r15.2      & r15.1      & r15.0      \\ \hline
\end{tabular}
\quad
\begin{tabular}{|l|l|l|l|l|}
\hline
\multicolumn{1}{|l|}{2:1 \textbackslash 1:0} & \textbf{3} & \textbf{2} & \textbf{1} & \textbf{0} \\ \hline
\multirow{4}{*}{\textbf{0}}                  & r3.0       & r2.0       & r1.0       & r0.0       \\
                                             & r3.1       & r2.1       & r1.1       & r0.1       \\
                                             & r3.2       & r2.2       & r1.2       & r0.2       \\
                                             & r3.3       & r2.3       & r1.3       & r0.3       \\ \hline
\multirow{4}{*}{\textbf{1}}                  & r7.0       & r6.0       & r5.0       & r4.0       \\
                                             & r7.1       & r6.1       & r5.1       & r4.1       \\
                                             & r7.2       & r6.2       & r5.2       & r4.2       \\
                                             & r7.3       & r6.3       & r5.3       & r4.3       \\ \hline
\multirow{4}{*}{\textbf{2}}                  & r11.0      & r10.0      & r9.0       & r8.0       \\
                                             & r11.1      & r10.1      & r9.1       & r8.1       \\
                                             & r11.2      & r10.2      & r9.2       & r8.2       \\
                                             & r11.3      & r10.3      & r9.3       & r8.3       \\ \hline
\multirow{4}{*}{\textbf{3}}                  & r15.0      & r14.0      & r13.0      & r12.0      \\
                                             & r15.1      & r14.1      & r13.1      & r12.1      \\
                                             & r15.2      & r14.2      & r13.2      & r12.2      \\
                                             & r15.3      & r14.3      & r13.3      & r12.3      \\ \hline
\end{tabular}
\caption{These two table show the per-byte layoute in standard and transposed
addressing modes. On the left is the standard addressing mode, where the
4-bit register address corresponds to rows in the table. On the right
is the transposed mode, where registers are addressed in four rows of
four columns.}
\label{tab:state-addr}
\end{table}

Unlike the RISC-V $\GPR$s, the zeroth $\CPR$ is not tied to zero.

\subsection{Instructions}

All instructions occupy the \encspace encoding space of the RISC-V opcode
map, using the associated \encopcode prefix for bits $6:0$ of each 
instruction.

\subsubsection{Move Instructions}
\paragraph{MVCOP}

Move a $\CPR$ register to a $\GPR$ register.

\begin{itemize}
\item \INST{MVCOP gpr, cpr}{
    $\GPR[*][\OPER{gpr}] \ASN \CPR[*][\OPER{cpr}]$
}
\end{itemize}


\paragraph{MVGPR[.t]}

The complement of \ASM{MVCOP}.
Move a $\GPR$ register to a $\CPR$ register.

\begin{itemize}
\item \INST{MVGPR cpr, gpr}{
    $\CPR[*][\OPER{cpr}] \ASN \GPR[*][\OPER{gpr}]$
}
\end{itemize}

\subsubsection{Packed Arithmetic}
\paragraph{ADD.px}

The instruction \ASM{ADD.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and adds corresponding fields together
ignoring any carry bits.

No overflow conditions are tested for, and \ASM{ADD.px} raises no exceptons.

\begin{itemize}
\item \INST{ADD.p8, rd, rs1, rs2}{
$\CPR[*][rd][ 3: 0] \ASN \CPR[*][rs1][ 3: 0] + \CPR[*][rs2][ 3: 0]$\\
$\CPR[*][rd][ 7: 4] \ASN \CPR[*][rs1][ 7: 4] + \CPR[*][rs2][ 7: 4]$\\
$\CPR[*][rd][11: 8] \ASN \CPR[*][rs1][11: 8] + \CPR[*][rs2][11: 8]$\\
$\CPR[*][rd][15:12] \ASN \CPR[*][rs1][15:12] + \CPR[*][rs2][15:12]$\\
$\CPR[*][rd][19:16] \ASN \CPR[*][rs1][19:16] + \CPR[*][rs2][19:16]$\\
$\CPR[*][rd][23:20] \ASN \CPR[*][rs1][23:20] + \CPR[*][rs2][23:20]$\\
$\CPR[*][rd][25:24] \ASN \CPR[*][rs1][25:24] + \CPR[*][rs2][25:24]$\\
$\CPR[*][rd][31:26] \ASN \CPR[*][rs1][31:26] + \CPR[*][rs2][31:26]$\\
}
\item \INST{ADD.p4, rd, rs1, rs2}{
$\CPR[*][rd][ 7: 0] \ASN \CPR[*][rs1][ 7: 0] + \CPR[*][rs2][ 7: 0]$\\
$\CPR[*][rd][15: 8] \ASN \CPR[*][rs1][15: 8] + \CPR[*][rs2][15: 8]$\\
$\CPR[*][rd][23:16] \ASN \CPR[*][rs1][23:16] + \CPR[*][rs2][23:16]$\\
$\CPR[*][rd][31:24] \ASN \CPR[*][rs1][31:24] + \CPR[*][rs2][31:24]$\\
}
\item \INST{ADD.p2, rd, rs1, rs2}{
$\CPR[*][rd][15: 0] \ASN \CPR[*][rs1][15: 0] + \CPR[*][rs2][15: 0]$\\
$\CPR[*][rd][31:16] \ASN \CPR[*][rs1][31:16] + \CPR[*][rs2][31:16]$\\
}
\item \INST{ADD.p1, rd, rs1, rs2}{
$\CPR[*][rd] \ASN \CPR[*][rs1] + \CPR[*][rs2]$\\
}
\end{itemize}

\paragraph{SUB.px}

The instruction \ASM{SUB.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and subtracts the {\tt rs2} fields from
the corresponding {\tt rs1} fields.

No overflow conditions are tested for, and \ASM{SUB.px} raises no exceptons.

\paragraph{MUL.px}

The instruction \ASM{MUL.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and multiplies the {\tt rs2} fields by
the corresponding {\tt rs1} fields.

No overflow conditions are tested for, and \ASM{MUL.px} raises no exceptons.

\paragraph{SLL.px}

The instruction \ASM{SLL.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and shifts the {\tt rs1} fields left
by the value in {\tt SHAMT}.

If the distance to shift by is greater than or equal to the size of each
packed field, then the result of the \ASM{SLL.px} instruction is
{\em implementation dependent}.

\paragraph{SRL.px}

The instruction \ASM{SRL.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and shifts the {\tt rs1} fields right
by the value in {\tt SHAMT}.

If the distance to shift by is greater than or equal to the size of each
packed field, then the result of the \ASM{SRL.px} instruction is
{\em implementation dependent}.

\paragraph{ROT.px}

The instruction \ASM{ROT.px} treats the source and destination registers as
1,2,4 or 8 unsigned, packed fields, and rotates the {\tt rs2} fields by
the value in {\tt SHAMT}.

\subsubsection{Bitwise and Twiddle Instructions}

\paragraph{XORT, ANDT, ORT}

The \ASM{XORT}, \ASM{ANDT}, and \ASM{ORT} instructions compute the
appropriate bitwise result of their operation between the {\tt rs1} and
{\tt rs2} operands. The result is then written into {\tt rd}.
\designnote{Originally the bitwise instructions were to have twiddle
functionality built-in, removing the need for a dedicated twiddle instruction.
The encoding space required however did not fit well with the existing RISC-V
register address and function field layout, and was extremely expensive.}

The difference between these instructions and their standard RISC-V
counterparts is that they operate on the $\CPR$ register file, and so
support the transposed addressing modes.

\begin{itemize}
\item \INST{XORT rd, rs1, rs2}{
    $ \CPR[*][\OPER{rd}] \ASN \CPR[*][rs1] \XOR \CPR[*][rs2] $ \\
}
\item \INST{ANDT rd, rs1, rs2}{
    $ \CPR[*][\OPER{rd}] \ASN \CPR[*][rs1] \AND \CPR[*][rs2] $ \\
}
\item \INST{ORT rd, rs1, rs2}{
    $ \CPR[*][\OPER{rd}] \ASN \CPR[*][rs1] \IOR \CPR[*][rs2] $ \\
}
\end{itemize}

Note that by having {\tt rs1} the same as {\tt rs2}, the twiddle
arithmetic instructions can be used to arbitrarily re-arrange bytes
within words. They can also be used to duplicate bytes within words.

\paragraph{TWID}

The \ASM{TWID} instruction is used to {\em twiddle} bytes within words.
It arbitrarily maps the bytes of a source word onto the bytes of a
destination word.

\begin{itemize}
\item \INST{TWID rd, rs1, b0, b1, b2, b3}{
    $ \CPR[*][\OPER{rd}][0] \ASN \CPR[*][\OPER{rs1}][\OPER{b0}] $ \\
    $ \CPR[*][\OPER{rd}][1] \ASN \CPR[*][\OPER{rs1}][\OPER{b1}] $ \\
    $ \CPR[*][\OPER{rd}][2] \ASN \CPR[*][\OPER{rs1}][\OPER{b2}] $ \\
    $ \CPR[*][\OPER{rd}][3] \ASN \CPR[*][\OPER{rs1}][\OPER{b3}] $ 
}
\end{itemize}


\subsubsection{Multi-precision Arithmetic}
\paragraph{ADD.m}
\paragraph{SUB.m}
\paragraph{ACC.m}
\paragraph{MAC.m}
\paragraph{SLL.m}
\paragraph{SRL.m}
\paragraph{EQU.m}
\paragraph{LTU.m}
\paragraph{GTU.m}

\subsubsection{Memory Access}

\paragraph{LBU.cr, LHU.cr, LW.cr}

The \ASM{LBU.cr}, \ASM{LHU.cr} and \ASM{LW.cr} instructions are analogous to
the standard RISC-V varients but with the following differences:

\begin{itemize}
\item They support transposition in their destination $\CPR$ register.
\item The halfword and byte varients can specify which halfword or byte of
      the destination register they are targeting.
\item The base address is taken from the normal RISC-V $\GPR$ set, while the
      target register is always in the $\CPR$ set.
\end{itemize}

These instructions will raise a {\em load address misaligned} instruction
if: the final source address is not aligned to the data type the instruction
is loading {\em and} the implementation does not support misaligned accesses.
The general rule here is that the \ASM{L*.cr} instructions should behave in
the same way as their RISC-V cousins in terms of exception handling,
interrupt behaviour and atomicity rules.

\begin{itemize}
\item \INST{LBU.cr  rd, b, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\CPR[*][rd][b] \ASN \MEM[*][addr]$
}
\item \INST{LHU.cr  rd, h, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $b_1 \ASN  (2'00_2 \IOR h) \LSH 1$ \\
    $b_2 \ASN  b_1 \IOR 1'1_2$ \\
    $\CPR[*][rd][b_2] \ASN \MEM[*][addr + 1]$ \\
    $\CPR[*][rd][b_1] \ASN \MEM[*][addr + 0]$
}
\item \INST{LW.cr  rd, imm(rs1)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\CPR[*][rd][rb + 3] \ASN \MEM[*][addr+3]$ \\
    $\CPR[*][rd][rb + 2] \ASN \MEM[*][addr+2]$ \\
    $\CPR[*][rd][rb + 1] \ASN \MEM[*][addr+1]$ \\
    $\CPR[*][rd][rb + 0] \ASN \MEM[*][addr+0]$
}
\end{itemize}

\note{
    The notation above assumes a byte addressed memory, where {\tt db}
    is a two bit byte address and {\tt dh} is a one bit halfword address.
}

\paragraph{SB.cr, SH.cr, SW.cr}

The \ASM{SB.cr}, \ASM{SH.cr} and \ASM{SW.cr} instructions are analogous to
the standard RISC-V varients but with the following differences:

\begin{itemize}
\item They support transposition in their source data $\CPR$ register.
\item The halfword and byte varients can specify which halfword or byte of
      the source register they store.
\item The base address is taken from the normal RISC-V $\GPR$ set, while the
      source data register is always in the $\CPR$ set.
\end{itemize}

These instructions will raise a {\em store address misaligned} instruction
if: the final source address is not aligned to the data type the instruction
is storing {\em and} the implementation does not support misaligned accesses.
The general rule here is that the \ASM{L*.cr} instructions should behave in
the same way as their RISC-V cousins in terms of exception handling,
interrupt behaviour and atomicity rules.

\begin{itemize}
\item \INST{SB.cr  rs1, b, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
     $\MEM[*][addr] \ASN \CPR[*][rs2][b]$
}
\item \INST{SH.cr  rs1, h, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $b_1 \ASN  (2'00_2 \IOR h) \LSH 1$ \\
    $b_2 \ASN  b_1 \IOR 1'1_2$ \\
    $\MEM[*][addr + 1] \ASN \CPR[*][rs2][b_2]$ \\
    $\MEM[*][addr + 0] \ASN \CPR[*][rs2][b_1]$
}
\item \INST{SW.cr  rs1, imm(rs2)}{
    $addr \ASN  \GPR[*][rs1] + signextend(imm, 32)$ \\
    $\MEM[*][addr+3] \ASN \CPR[*][rd][rb + 3]$ \\
    $\MEM[*][addr+2] \ASN \CPR[*][rd][rb + 2]$ \\
    $\MEM[*][addr+1] \ASN \CPR[*][rd][rb + 1]$ \\
    $\MEM[*][addr+0] \ASN \CPR[*][rd][rb + 0]$
}
\end{itemize}

\note{
    The notation above assumes a byte addressed memory, where {\tt b}
    is a two bit byte address and {\tt h} is a one bit halfword address.
}

\paragraph{SCATTER[.t]}
\paragraph{GATHER[.t]}


\subsection{Instruction Encodings}

Lorem ipsum doler set amet.


