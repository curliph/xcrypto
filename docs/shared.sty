\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[plain,shortend]{algorithm2e}
\usepackage[backend=biber,style=numeric]{biblatex}
\usepackage{bytefield}
\usepackage{currfile}
\usepackage[margin={2cm}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{tikz}
\usepackage{url}
\usepackage{xargs}
\usepackage{xspace}
\usepackage{xstring}
\usepackage{import}
\usepackage{hyperref}
\usepackage{multirow}

\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.shapes}
\usetikzlibrary{decorations.text}
\usetikzlibrary{fit}

% -----------------------------------------

% Design choice notes
\newcommand{\designnote}[1]{\footnote{#1}}
\newcommandx{\note}[1]{{\bf Note:} #1\\}

\newcommand{\encspace}{{\em custom1} }
\newcommand{\encopcode}{$0101011$}

\newcommandx{\ASM}[1]{{\tt #1}}

\newcommandx{\BB}[2]{\bitbox{#1}{{\tt #2}}}
\newcommandx{\BH}[2]{\bitbox{#1}{{\bf #2}}}

\newcommandx{\INST}[2]{
  \ASM{#1}
  \\
  \begin{algorithm}[H]
  #2
  \end{algorithm}
}

% -----------------------------------------

% calligraphic (e.g., for mathematical spaces)
\newcommandx{\C}[1]{\ensuremath{\mathcal #1}\xspace}
% black board  (e.g., for mathematical structures)
\newcommandx{\B}[1]{\ensuremath{\mathbb  #1}\xspace}
% algorithm
\newcommandx{\ALG}[1]{\textsc{#1}}
% instruction operand
\newcommandx{\OPER}[1]{\mbox{\tt #1}}
% scoping
\newcommandx{\FIELD}[2]{\ensuremath{#1}[{#2}]\xspace}
\newcommandx{\SCOPE}[2]{\ensuremath{#1}.{#2}\xspace}
% truth values
\newcommandx{\TRUE}{\mbox{\rm\bf true}\xspace}
\newcommandx{\FALSE}{\mbox{\rm\bf false}\xspace}
% radix and representation
\newcommandx{\RADIX}[2]{\ensuremath{{#1}_{({#2})}}\xspace}
\newcommandx{\REP}[1]{\ensuremath{\hat{#1}}\xspace}
% assignment and definition
\newcommandx{\ASN}{\ensuremath{\leftarrow}\xspace}
\newcommandx{\DEF}{\ensuremath{:=}\xspace}
% random sample
\newcommandx{\RAND}{\xleftarrow{\$}}
% test
\newcommandx{\TEST}[1]{\overset{?}{#1}}
% least- or most-significant bits
\newcommandx{\LSB}[2][1={1}]{\ensuremath\textsc{LSB}_{\IfEq{#1}{1}{}{#1}}( #2 )\xspace}
\newcommandx{\MSB}[2][1={1}]{\ensuremath\textsc{MSB}_{\IfEq{#1}{1}{}{#1}}( #2 )\xspace}
% parity, Hamming weight, and Hamming distance
\newcommandx{\PARITY}[1][1={}]{\ensuremath{\mathcal P}^{#1}\xspace}
\newcommandx{\HW}{\ensuremath{\mathcal H}\xspace}
\newcommandx{\HD}{\ensuremath{\mathcal D}\xspace}
% signed vs. unsigned operator
\newcommandx{\SOP}[2]{\ensuremath{#1}_{#2}\xspace}
% sign extension
\newcommandx{\EXT}[2][1={}]{\ensuremath\ext^{#2}_{#1}\xspace}
% left- and right-shift, and left- and right-rotate
\newcommandx{\LSH}{\ensuremath{\ll}\xspace}
\newcommandx{\RSH}{\ensuremath{\gg}\xspace}
\newcommandx{\LRT}{\ensuremath{\lll}\xspace}
\newcommandx{\RRT}{\ensuremath{\ggg}\xspace}
% Boolean operators
\newcommandx{\NAND}{\ensuremath{\;\overline{\wedge}\;}\xspace}
\newcommandx{\NIOR}{\ensuremath{\;\overline{\vee}\;}\xspace}
\newcommandx{\NXOR}{\ensuremath{\;\overline{\oplus}\;}\xspace}
\newcommandx{\XNOR}{\ensuremath{\;\overline{\oplus}\;}\xspace}
\newcommandx{\NOT}{\ensuremath{\neg  }\xspace}
\newcommandx{\AND}{\ensuremath{\wedge}\xspace}
\newcommandx{\IOR}{\ensuremath{\vee  }\xspace}
\newcommandx{\XOR}{\ensuremath{\oplus}\xspace}
% type- or structure-annotated operators
\newcommandx{\SID}[2][1={}]{#2_{\mathsmaller{#1}}}
\newcommandx{\SADD}[1][1={}]{\ensuremath{\oplus_{\mathsmaller{#1}}}\xspace}
\newcommandx{\SSUB}[1][1={}]{\ensuremath{\ominus_{\mathsmaller{#1}}}\xspace}
\newcommandx{\SDOT}[1][1={}]{\ensuremath{\odot_{\mathsmaller{#1}}}\xspace}
\newcommandx{\SMUL}[1][1={}]{\ensuremath{\otimes_{\mathsmaller{#1}}}\xspace}
\newcommandx{\SDIV}[1][1={}]{\ensuremath{\oslash_{\mathsmaller{#1}}}\xspace}
% collections
\newcommandx{\TUPLE}[1]{\ensuremath{({#1})}\xspace}
\newcommandx{\TABLE}[1]{\ensuremath{[{#1}]}\xspace}
\newcommandx{\LIST}[1]{\ensuremath{\langle{#1}\rangle}\xspace}
\newcommandx{\SET}[1]{\ensuremath{\{{#1}\}}\xspace}
% concatination
\newcommandx{\CONS}{\ensuremath{\;\parallel\;}\xspace}
% set builder st.
\newcommandx{\ST}{\ensuremath{\;|\;}\xspace}
% something within a given round (e.g., of a block cipher)
\newcommandx{\ROUND}[2]{\ensuremath{#1}^{(#2)}}
% word size
\newcommandx{\W}{\ensuremath{w}\xspace}
% memory, general-purpose and special-purpose registers
\newcommandx{\MEM}[3][1={},2={},3={}]{{\ensuremath\IfEq{#1}{*}{{\sf  MEM}[{#2}]^{#3}}{{\sf   MEM}}}\xspace}
\newcommandx{\GPR}[2][1={},2={}     ]{{\ensuremath\IfEq{#1}{*}{{\sf  GPR}[{#2}]     }{{\sf   GPR}}}\xspace}
\newcommandx{\CPR}[2][1={},2={}     ]{{\ensuremath\IfEq{#1}{*}{{\sf  CPR}[{#2}]     }{{\sf   CPR}}}\xspace}
\newcommandx{\SPR}[3][     2={},3={}]{{\ensuremath\IfEq{#2}{*}{{\sf   #1}[{#3}]     }{{\sf    #1}}}\xspace}

% set (approximate) styles
\lstalias{RV}{C}

\lstdefinestyle{inline}{
  escapechar={¬},
  basicstyle=\ttfamily, 
  keywordstyle=\ttfamily, 
  breakautoindent=false,
  breaklines=false,
  breakatwhitespace=false,
  keepspaces=true,
  showstringspaces=false
}
\lstdefinestyle{float}{
  escapechar={¬},
  basicstyle=\ttfamily\scriptsize,  
  breakautoindent=false,
  breaklines=false,
  breakatwhitespace=false,
  keepspaces=true,
  showstringspaces=false,
  frame=single
}
\lstdefinestyle{block}{
  escapechar={¬},
  basicstyle=\ttfamily\scriptsize,  
  breakautoindent=false,
  breaklines=false,
  breakatwhitespace=false,
  keepspaces=true,
  showstringspaces=false,
  frame=single
}

% provide inline verbatim, e.g., \VERB[C]{text}
\newcommand{\VERB}[2][]{\mbox{\lstinline[style={inline},language={#1}]`#2`}}
% provide block  verbatim, e.g., \begin{MKVERB}[language=C,style={foo}]
\lstnewenvironment{MKVERB}[1][]{\lstset{basicstyle=\ttfamily,#1}}{}

% http://tex.stackexchange.com/questions/164664/how-to-create-an-array-with-both-vertical-and-horizontal-braces-around-the-eleme
\newcommand\undermat[2]{%
  \makebox[0pt][l]{$\smash{\underbrace{\phantom{%
    \begin{matrix}#2\end{matrix}}}_{\text{$#1$}}}$}#2}
