\documentclass{article}

\usepackage{shared}

\usepackage{biblatex}
\addbibresource{references.bib}

\title{SCARV: RISC-V Crypto ISE \\ Reference Implementation}

\begin{document}

%% Custom Commands %%

\newcolumntype{Y}{>{\RaggedRight\arraybackslash}X}

\newcommand{\SIGNALS}[1]{
\begin{table}[H]
\begin{tabularx}{\textwidth}{@{} c c l Y @{}}
\toprule
\textbf{I/O} & \textbf{Size} & \textbf{Name} & \textbf{Description} \\
\midrule
#1
\bottomrule
\end{tabularx}
\end{table}
}
\newcommand{\SIGREF}[1]{{\tt #1}}
\newcommand{\SIGNALI}[3]{
    {\bf I} & $#1$ &{\tt #2}& #3 \\ \addlinespace
}
\newcommand{\SIGNALO}[3]{
    {\bf O} & $#1$ &{\tt #2}& #3 \\ \addlinespace
}

%% End Custom Commands %%

\maketitle

\abstract{
This document contains the micro-architectural specification for an
implementation of the RISC-V Crypto ISE.
}
\tableofcontents

\section{Introduction}

This document contains the design specification for an {\em area optimised}
implementation of the proposed RISC-V Crypto ISE (C-ISE).

The implementation takes the form of a Co-processor (COP), which is designed
to make it extremely easy to re-use, and integrate with existing RISC-V cores
which support custom ISEs. We define the interfaces to the Co-processor, as
well as it's internal micro-architecture and how to integrate it with an
existing CPU core.

Note that this is only a reference implementation. It is not the only way
to implement the ISE, nor is it the best for any given set of design
constraints. It would be perfectly acceptable to create a single CPU core
which tightly integrates the ISE into it's execution pipeline (as one might
with a core supporting the floating-point F extension), rather than
attatching to it as a co-processor. There are numerous performance and
efficiency improvements to be had from such an approach. We used a
co-processor architecture because it make re-use with existing CPU designs
(such as picorv32 or Rocket) much easier.

The rest of the document is structured as follows: Section 
\ref{sec:cop-interfaces} describes the interfaces of the COP. Section
\ref{sec:cop-microarch} describes the internal organisation of the COP.
Section \ref{sec:integration} details how to integrate the COP into an
existing RISC-V processor design. Section \ref{sec:verification} describes
how the COP implementation was verified.

\section{COP Interfaces}
\label{sec:cop-interfaces}

Here, we detail the interfaces to the COP. By defining this interface, we
hope that others can modify the internals of the COP to suite their own
design constraints, and still have a drop-in compatible design.

\subsection{Clock and Reset Interface}
\label{sec:if-clk-reset}

\SIGNALS{
\SIGNALI{1}{g\_clk}{The global input clock signal.}
\SIGNALO{1}{g\_clk\_req}{
COP clock request signal. The COP sets this signal high when it needs a
clock signal, and clears it when it does not. Used to indicate the COP
is idle.
}
\SIGNALI{1}{g\_resetn}{Synchronous, active low reset signal.}
}

\subsection{Status Interface}

TBD

\subsection{CPU/COP Interface}

The CPU/COP interface is the channel through which the CPU can send
instructions to the COP and recieve results.
The four signals
{\tt cpu\_insn\_req, cop\_insn\_ack, cpu\_insn\_ack} and
{\tt cop\_insn\_rsp}
control the rate of information flow between the CPU and the COP.

\subsubsection{Signal List}

\SIGNALS{
\SIGNALI{1}{cpu\_insn\_req}{
    Set by the CPU to indicate a new instruction needs to be executed.
    There must be no combinatorial path from {\tt cpu\_insn\_req} to  
    {\tt cop\_insn\_ack}.
}
\SIGNALO{1}{cop\_insn\_ack}{
    Co-processor acknowledge. This is asserted by the co-processor to say
    that it has received the data from the CPU and will start working on the
    supplied instruction.
}
\SIGNALI{1}{cpu\_abort\_req}{
    Set by the CPU to tell the COP to abort whatever instruction it is
    executing (if any) and return to an idle state where it is ready to
    accept new instructions. This signal is used to abort long multi-cycle
    instructions in the presence of a pending interrupt.
    There must be no combinatorial path from {\tt cpu\_insn\_abort} to
    {\tt cop\_insn\_ack}.
}
\SIGNALI{32}{cpu\_insn\_enc}{
    The encoded instruction word to be executed by the COP.
}
\SIGNALI{32}{cpu\_rs1}{
    The value of $\GPR$ source 1 ({\tt rs1}), which is used as the source
    register for some ISE instructions. The CPU only needs to provide this
    for a very small subset of the ISE instructions: \ASM{SB.cr, SH.cr,
        SW.cr, SCATTER.x, GATHER.x} and \ASM{MV2CPR}.
}
\SIGNALO{1}{cop\_wen}{
    Co-processor write enable, indicates to the CPU that a value needs to
    be written from the co-processor {\tt cop\_wdata} signal into the
    RISC-V GPR register addressed by {\tt cop\_waddr}.
}
\SIGNALO{5}{cop\_waddr}{
    The RISC-V GPR destination register address used by the COP instructions
    \ASM{MV2GPR, EQU.mp, LTU.MP} and \ASM{GTU.mp}.
}
\SIGNALO{32}{cop\_wdata}{
    The data to be written to the RISC-V GPR register addressed by 
    {\tt cop\_waddr} by the 
    \ASM{MV2GPR, EQU.mp, LTU.MP} and \ASM{GTU.mp}
    instructions.
}
\SIGNALO{3}{cop\_result}{
    This signal encodes the result of the executed instruction: whether
    it succeeded or, if it raised an exception, what kind. The encodings
    are described in table \ref{tab:cop-result-encodings}.
}
\SIGNALO{1}{cop\_insn\_rsp}{
    Co-processor response. Used to indicate processing of the current
    instruction has finished and that we are ready for the next one. Writeback
    and response data is valid when this signal is set.
    There must be no combinatorial path from {\tt cpu\_insn\_rsp} to
    {\tt cpu\_insn\_ack}.
}
\SIGNALO{1}{cpu\_insn\_ack}{
    Allows the CPU to signal to the co-processor it has recieved all
    information from the execution of an instruction.
}
}


\begin{table}[h!]
\centering
\begin{tabular}{ll}
\toprule
{\bf Result Code} & {\bf Meaning} \\
\midrule
 {\tt 0b000}  & Success \\
 {\tt 0b001}  & Aborted \\
 {\tt 0b010}  & Instruction decode exception \\
 {\tt 0b100}  & Load address misaligned exception  \\
 {\tt 0b101}  & Store address misaligned exception \\
 {\tt 0b110}  & Load access fault                  \\
 {\tt 0b111}  & Store access fault                 \\
 \bottomrule
\end{tabular}
\caption{Encodings for the \SIGREF{cop\_result} signal. All other encoding
values are reserved and should not be used.}
\label{tab:cop-result-encodings}
\end{table}

\subsubsection{Example Transactions}

This section gives a non-exhaustive list of timing diagrams for example
transactions over the CPU/COP interface.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./diagrams/cpu-cop-if-1.png}
\caption{Simple instruction request, acknowledge, result with delays.
The first transaction shows an instruction request in cycle 1, followed
by the acknlowedgement and result in cycle 2.
The second shows that if {\tt cop\_insn\_ack} is set already, then
instructions can be accepted immediately and their result returned on the next
cycle.  The third shows how the request / acknowledge protocol handles
stalls.}
\label{fig:cpu-cop-if-waves-1}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./diagrams/cpu-cop-if-2.png}
\caption{This figure shows the same three transactions as in figure
\ref{fig:cpu-cop-if-waves-1} but with the requests issued back to back.
In the set of transactions, the results of each transacton are not always
accepted on the next cycle. In the second set, we see the interface working
at maximum throughput, with every request accepted in the same cycle, and
results always accepted in the next cycle.}
\end{figure}



\subsection{Memory Interface}

The COP uses a single extra memory interface in order to implement the
load/store instructions. It is a simple SRAM-style interface which can be
connected directly to a BRAM, converted into a bus interconnect (AXI4-Lite
for example) or multiplexed with the CPU data memory interface.

The interface uses a 32-bit, word aligned address. Misaligned accesses
are {\em not} supported in this implementation of the ISE and will raise
a {\em misaligned load/store exception} via the CPU/COP interface.

\subsubsection{Signal List}

These signals are synchronous with the {\tt g\_clk} signal described in
section \ref{sec:if-clk-reset}.

\SIGNALS{
\SIGNALO{1}{cop\_mem\_cen}{
    Memory chip enable, signaling an active transaction. When asserted this
    signal must stay set until the following cycle, where it can be cleared
    iff {\tt cop\_mem\_stall} is clear. If the stall signal is not clear, it
    must remain set until either stall is clear, or {\tt cop\_mem\_error}
    is high.
}
\SIGNALO{1}{cop\_mem\_wen}{
    Memory write enable. Must remain stable during a transaction.
}
\SIGNALO{32}{cop\_mem\_addr}{
    Memory address. Must remain stable during a transaction.
}
\SIGNALO{32}{cop\_mem\_wdata}{
    Memory write data. Must remain stable during a transaction.
}
\SIGNALO{4}{cop\_mem\_ben}{
    Memory byte enable. On a write, this indicates which bytes in the word
    are to be updated. On a read, this indicates which bytes of the word we
    are looking to have returned. Must remain stable during a transaction.
}
\SIGNALI{32}{cop\_mem\_rdata}{
    Memory read data.
}
\SIGNALI{1}{cop\_mem\_stall}{
    Memory stall, indicating the COP must wait another cycle for the response.
}
\SIGNALI{1}{cop\_mem\_error}{
    Memory error. Indicates the COP has tried to access unmapped or otherwise
    invalid memory space. The error signal can only be asserted when the
    chip enable is high in the previous cycle. The chip enable must be
    cleared when the error signal is asserted.
}
}

\subsubsection{Example Transactions}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./diagrams/cop-mem-if-1.png}
\caption{This timing diagram shows a read, followed by a stalled read,
followed by a write, and finally a stalled write on the COP memory interface.
Note that {\tt cop\_mem\_cen} remains high for only a single cycle in a
non-stalled transaction, but must remain high while the stall signal is also
asserted.}
\label{fig:cop-mem-if-waves-1}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./diagrams/cop-mem-if-2.png}
\caption{This timing diagram shows the same set of transactions as in
\ref{fig:cop-mem-if-waves-1} but back-to-back with no intervening cycles
where the bus is idle.}
\label{fig:cop-mem-if-waves-2}
\end{figure}


\section{COP Internal Micro-architecture}
\label{sec:cop-microarch}

\subsection{COP Register File}

\subsection{Packed Arithmetic Unit}

\subsection{Multi-precision Arithmetic Unit}

\subsection{Memory Unit}


\section{Integration Guide}
\label{sec:integration}


\section{Verification}
\label{sec:verification}


\printbibliography


\end{document}
