% =============================================================================

\subsection{Features}
\label{sec:bg:feature}

\begin{table}[t]
\begin{center}
\begin{tabular}{|l|cc|}
\hline
Feature class   & Numeric ID & Mnemonic ID \\
\hline
Baseline        & $1$        & BASE        \\
Randomness      & $2.1$      & RND         \\
Memory          & $2.2$      & MEM         \\
Bit-oriented    & $2.3$      & BIT         \\
Packed          & $2.4$      & PACK        \\
Multi-precision & $2.5$      & MP          \\
\hline
\end{tabular}
\end{center}
\caption{A list of feature classes, plus their associated numeric and mnemonic identifiers.}
\label{tab:feature}
\end{table}

Per \REFSEC{sec:bg:concept}, \XCID is a {\em meta}-extension in that it has 
a) one baseline feature class,
   which must {\em always} be supported,
   plus
b) several optional feature classes,
   which can be {\em selectively} supported to suit.
It acts to mirror the extensibility afforded by RV32I itself, with similar
motivation: doing so allows one to tailor the ISE (resp. ISA) st. it suits
a given context, which is important because some features are applicable 
within a broad range of cryptographic workloads whereas others are (more) 
specifically applicable (even niche).  Although \REFSEC{sec:spec} offers a 
precise specification, note that

\begin{itemize}
\item support for a given feature class can be determined programmatically 
      using an associated CSR,
\item all feature classes in \XCID can emulated by using RV32I alone,
\item attempted execution of any instruction from an unsupported feature 
      class will cause an 
      illegal instruction exception,
      and
\item any instruction that accesses memory mirrors RV32I wrt. exception,
      synchronisation (e.g., \VERB[RV]{FENCE}), and atomicity semantics: 
      for example, if
      a) the effective address stemming from a memory access instruction
         is not aligned to the associated data type, 
         {\em  and}
      b) the implementation does not support misaligned accesses,
         {\em then}
         it will cause a 
         load/store address misaligned exception.
\end{itemize}

\noindent
The RISC-V naming convention~\cite[Section 22]{SCARV:RV:ISA:I:17} for ISEs
uses a string of single-character identifiers to specify features realised
in an implementation.  We adopt a variant of this approach, wherein
\[
\XCID[x/y/z]
\]
denotes a concrete implementation of \XCID that supports feature classes 
$x$, $y$, and $z$: we assign a numeric and a mnemonic identifier to each
feature class (summarised by \REFTAB{tab:feature}).  For example,
\[
\XCID[1/2.1/2.2/2.3/2.4] ~\equiv~ \XCID[BASE/RND/MEM/BIT/PACK]
\]
describes an implementation which supports
a) the core features,
b) features relating to generation of randomness,
c) features relating to advanced memory access, namely scatter/gather
   style store and load operations,
d) features relating to bit-oriented (i.e., Boolean) operations,
   plus
e) features relating to packed (or DSP-like) arithmetic operations:
such an implementation is tailored to suit symmetric cryptography (e.g.,
AES), but {\em not} asymmetric cryptography (e.g., RSA).

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:bg:feature:1}

\XCID attempts to avoid unnecessary additional state.  Even so, it {\em does}
introduce

\begin{itemize}
\item $1$ additional $16$-entry co-processor register file,
      and
\item $2$ additional CSRs 
      (one is used to report on features in, the other to control an implementation of \XCID),
\end{itemize}

\noindent
as a baseline; most of the instructions specified in this class allow access 
to said state.

\subparagraph{Register-register data transfer.}

A suite of instructions
(e.g., \VERB[RV]{MV2COP.cr})
that allow 
transfer of content between
the general-purpose register file (i.e., $\GPR$)
and
the    co-processor register file (i.e., $\XCR$)
is included.
In addition, support 
(e.g., \VERB[RV]{CMOV.cr})
for conditional, branch'less moves of content between $\XCR$ registers 
(cf. x86 \VERB{cmov}~\cite[Page 3-149--3-152]{SCARV:X86:2:18})
is included; such instructions form a common, vital component
(see, e.g., \cite[Section 5]{SCARV:RFC:7748} wrt. requirement for \VERB{cswap})
in realisations of countermeasures against side-channel attack.

\subparagraph{Register-memory   data transfer.}

A suite of instructions 
(e.g., \VERB[RV]{LW.cr})
that allow 
transfer of content between
   memory                         (i.e., $\MEM$)
and
the    co-processor register file (i.e., $\XCR$)
is included.
All such instructions use a base address in $\GPR$, but {\em directly} load 
and store to and from $\XCR$; this avoids having to first load content into 
and then subsequently transfer it from $\GPR$.
Although most are analogous to RV32I, there are some differences: note that

\begin{itemize}
\item variants that support different access granularity (e.g., halfword or
      byte) are included; variants that support inserting (vs. overwriting)
      load semantics are also included,
\item matching the context, access is considered to be unsigned throughout;
      there are no sign-extending variants, for example.
\end{itemize}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:bg:feature:2:1}

Almost all cryptographic workloads have a strong requirement for efficient
generation of high-quality randomness; this stems from use-cases such as
a) generation of key material, be it ephemeral or long term,
   or
b) implementation of (randomised) countermeasures
   (see, e.g., masking~\cite[Chapter 9]{SCARV:ManOswPop:07}).
Any lack of quality can be outright catastrophic;
for context and (more recent) real-world impact see, e.g.,~\cite{SCARV:KSWH:98,SCARV:RFC:4086} and~\cite{SCARV:NSSKM:17} respectively.
The same is true of efficiency, the lack of which can lead to trade-offs 
that favour execution latency but degrade security.

As a result, many ISAs now include an interface with an underlying (T)RNG
implementation; examples include
x86~\cite[Section 7.3.17.1 and 7.3.17.2]{SCARV:X86:2:18} 
(see also~\cite{SCARV:JunKoc:99,SCARV:HamKocMar:12})
and
ARMv8.5-A\footnote{
\url{https://community.arm.com/processors/b/blog/posts/arm-a-profile-architecture-2018-developments-armv85a}
}.  \XCID mirrors such designs, including
A suite of instructions 
that allow 
manipulation, e.g.,
 sampling entropy from (via \VERB[RV]{RSAMP.cr})
or
injecting entropy into (via \VERB[RV]{RSEED.cr})
a (T)RNG implementation.

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.2$: memory}
\label{sec:bg:feature:2:2}

Consider the concept of an S-box (or substitution box), as evident in many 
symmetric primitive designs.  Such an S-box can be described abstractly as 
a Boolean function
\[
\ALG{S-box} : \SET{ 0, 1 }^{n} \rightarrow \SET{ 0, 1 }^{m} ,
\]
st. it substitutes an $n$-bit input for an $m$-bit output.  Both 
the general-case of $n \neq m$
(cf. DES~\cite{SCARV:FIPS:46_3} where $n = 6$ and $m = 4$),
and 
the special-case of $n =    m$
(cf. AES~\cite{SCARV:FIPS:197}  where $n = m = 8$)
are useful in practice, but, either way, the idea is to apply S-box(es) to
some intermediate state to realise some form of confusion step: see, e.g., 
\cite[Section 1.3]{SCARV:KnuRob:11}.
From an implementation perspective, it is common to store each S-box as a
look-up table; although said pre-computation implies some memory overhead
(related to $n$ and $m$).
However, as outlined by Fiskiran and Lee~\cite{SCARV:FisLee:01}, {\em if}
such an approach is used then the addressing modes available {\em may} be
a factor in any concrete improvement in latency.

This, taken as an exemplar from a richer set of examples, forms motivation
for a richer set of addressing modes than available (by design) in RV32I.
In particular, 
a suite of instructions 
(e.g., \VERB[RV]{SCATTER.b} and \VERB[RV]{GATHER.b})
that allow 
scatter/gather-based
transfer of content between
   memory                         (i.e., $\MEM$)
and
the    co-processor register file (i.e., $\XCR$)
is included: the idea is to specify {\em multiple} memory accesses using a
single base address and multiple offsets, and hence scatter sub-words into 
(resp. gather sub-words from) memory at non-contiguous addresses.  
This capability clearly aligns with application of an S-box, with the AES 
{\tt SubBytes}~\cite[Section 5.1.1]{SCARV:FIPS:197} 
round function implementable via a single \VERB[RV]{GATHER.b} instruction 
(albeit multiple resulting memory accesses) given a suitable look-up table.
Couching scatter/gather as a vector-oriented operation, both
\cite[Section 3.1]{SCARV:FouMoo:05} 
and 
\cite[Section 3.3]{SCARV:Fournier:07}
expand on such approach.

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:bg:feature:2:3}

Particularly wrt. symmetric primitives, the use of bit-oriented operations 
is common in implementations of cryptography.  At a high level, and though 
counterexamples do exist 
(see, e.g., IDEA~\cite{SCARV:LaiMas:90}, RC6~\cite{SCARV:RRSY:98}),
this fact can be explained by use of alternative (i.e., not word-oriented
and/or not supported by arithmetic in most ISAs) structures and concepts,
and thus operations, in relevant designs.  Associated design rationale may
include
a) security
   (e.g., bit-sliced implementation~\cite{SCARV:KasSch:09} AES~\cite{SCARV:FIPS:197} to mitigate cache-based side-channel attacks),
   or
b) efficiency
   (e.g., use of hardware-friendly bit-permutations in DES~\cite{SCARV:FIPS:46_3})
As a result, numerous proposals for associated ISEs exist; these typically
act to accelerate in software what would otherwise represent a high (even 
prohibitive) overhead.  \XCID adopts a similar approach.

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.4$: packed}
\label{sec:bg:feature:2:4}

% TODO

%It is common for some CPUs / DSP extensions to allow packed ALU operations.
%This is essentially using the normal GPRs to do SIMD operations on multiple
%pieces of data which are either a halfword or a byte in size. We include
%variants of such instructions which operate on data widths commonly
%found in cryptographic algorithms, particularly block ciphers.

% case in point, PRESENT; post-quantum schemes mod 2^{16}




%By default, the packed arithmetic width instructions detailed in
%section \ref{sec:packed-arithmetic-instructions} support operations on
%packed bit-fields of widths $2$, $4$, $8$, $16$ and $32$.
%
%For extremely resource constrained or application specific implementations,
%some unnecessary pack widths (as defined by the implementer) may be omitted.
%
%Supported pack widths are indicated by the {\tt pX} bits of the
%\nameref{sec:csr-mccr}.
%
%Packed arithmetic instructions operating on supported pack widths are
%executed as normal. If a packed arithmetic instruction operating on an
%unsupported pack width is encountered, the implementation should raise an
%{\em Illegal Instruction} exception.

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:bg:feature:2:5}

Modular, multi-precision integer arithmetic forms a foundation for various
cryptographic use-cases, but particularly asymmetric primitives; examples 
include
RSA (relying on arithmetic in $\B{Z}_N$ for large $N$),
and
ECC (relying on arithmetic in $\B{F}_p$ for large $p$).
As such, there is a large body of literature on the implementation of said 
arithmetic; this includes support for implementations via ISEs defined for 
RISC-based processors.

\XCID includes a suite of instructions 
(e.g., \VERB[RV]{ADD3.mp})
which mirror low-level steps in higher-level algorithms for multi-precision 
integer arithmetic; in part, these mirror features in 
XS1~\cite[Section 18]{SCARV:XS1:09} 
there termed ``long arithmetic''.  A central design principle is that every
instruction explicitly accepts {\em all} input required: this implies there
is no additional
explicit (e.g., accumulator register) 
nor 
implicit (e.g., status flags for carry or borrow)
state.
Such an approach is particularly attractive when set within the context of 
RV32I, because it avoids inclusion of status flags and so forces (somewhat 
high overhead) software-based carry and overflow detection.

% =============================================================================
