% =============================================================================

\subsection{Features}
\label{sec:bg:feature}

\begin{table}[t]
\begin{center}
\begin{tabular}{|l|cc|}
\hline
Feature class   & Numeric ID & Mnemonic ID \\
\hline
Baseline        & $1$        & BASE        \\
Randomness      & $2.1$      & RND         \\
Memory          & $2.2$      & MEM         \\
Bit-oriented    & $2.3$      & BIT         \\
Packed          & $2.4$      & PACK        \\
Multi-precision & $2.5$      & MP          \\
\hline
\end{tabular}
\end{center}
\caption{A list of feature classes, plus their associated numeric and mnemonic identifiers.}
\label{tab:feature}
\end{table}

Per \REFSEC{sec:bg:concept}, \XCID is a {\em meta}-extension in that it has 
a) one baseline feature class,
   which must {\em always} be supported,
   plus
b) several optional feature classes,
   which can be {\em selectively} supported to suit.
It acts to mirror the extensibility afforded by RV32I itself, with similar
motivation: doing so allows one to tailor the ISE (resp. ISA) st. it suits
a given context, which is important because some features are applicable 
within a broad range of cryptographic workloads whereas others are (more) 
specifically applicable (even niche).  Although \REFSEC{sec:spec} offers a 
precise specification, note that

\begin{itemize}
\item support for a given feature class can be determined programmatically 
      using an associated CSR,
\item all feature classes in \XCID can emulated by using RV32I alone,
\item attempted execution of any instruction from an unsupported feature 
      class will cause an 
      illegal instruction exception,
      and
\item any instruction that accesses memory mirrors RV32I wrt. exception,
      synchronisation (e.g., \VERB[RV]{FENCE}), and atomicity semantics: 
      for example, if
      a) the effective address stemming from a memory access instruction
         is not aligned to the associated data type, 
         {\em  and}
      b) the implementation does not support misaligned accesses,
         {\em then}
         it will cause a 
         load/store address misaligned exception.
\end{itemize}

\noindent
The RISC-V naming convention~\cite[Section 22]{SCARV:RV:ISA:I:17} for ISEs
uses a string of single-character identifiers to specify features realised
in an implementation.  We adopt a variant of this approach, wherein
\[
\XCID[x/y/z]
\]
denotes a concrete implementation of \XCID that supports feature classes 
$x$, $y$, and $z$: we assign a numeric and a mnemonic identifier to each
feature class (summarised by \REFTAB{tab:feature}).  For example,
\[
\XCID[1/2.1/2.2/2.3/2.4] ~\equiv~ \XCID[BASE/RND/MEM/BIT/PACK]
\]
describes an implementation which supports
a) the core features,
b) features relating to generation of randomness,
c) features relating to advanced memory access, namely scatter/gather
   style store and load operations,
d) features relating to bit-oriented (i.e., Boolean) operations,
   plus
e) features relating to packed (or DSP-like) arithmetic operations:
such an implementation is tailored to suit symmetric cryptography (e.g.,
AES), but {\em not} asymmetric cryptography (e.g., RSA).

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:bg:feature:1}

\XCID attempts to avoid unnecessary additional state.  Even so, it {\em does}
introduce

\begin{itemize}
\item $1$ additional $16$-entry co-processor register file,
      and
\item $2$ additional CSRs 
      (one is used to report on features in, the other to control an implementation of \XCID),
\end{itemize}

\noindent
as a baseline; most of the instructions specified in this class allow access 
to said state.

\paragraph{Register-register data transfer.}

A suite of instructions
(e.g., \VERB[RV]{MV2COP.cr})
allow transfer of content between
the general-purpose register file (i.e., $\GPR$)
and
the    co-processor register file (i.e., $\XCR$)
is included.
In addition, support 
(e.g., \VERB[RV]{CMOV.cr})
for conditional, branch'less moves of content between $\XCR$ registers 
(cf. x86 \VERB{cmov}~\cite[Page 3-149--3-152]{SCARV:X86:2:18})
is included; such instructions form a common, vital component
(see, e.g., \cite[Section 5]{SCARV:RFC:7748} wrt. requirement for \VERB{cswap})
in realisations of countermeasures against side-channel attack.

\paragraph{Register-memory   data transfer.}

A suite of instructions 
(e.g., \VERB[RV]{LW.cr})
allow transfer of content between
   memory                         (i.e., $\MEM$)
and
the    co-processor register file (i.e., $\XCR$)
is included.
All such instructions use a base address in $\GPR$, but {\em directly} load 
and store to and from $\XCR$; this avoids having to first load content into 
and then subsequently transfer it from $\GPR$.
Although most are analogous to RV32I, there are some differences: note that

\begin{itemize}
\item variants that support different access granularity (e.g., halfword or
      byte) are included; variants that support inserting (vs. overwriting)
      load semantics are also included,
\item matching the context, access is considered to be unsigned throughout;
      there are no sign-extending variants, for example.
\end{itemize}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:bg:feature:2:1}

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.2$: memory}
\label{sec:bg:feature:2:2}

%\cite{SCARV:FisLee:01}

%The {\tt SCATTER} and {\tt GATHER} byte/halfword instructions described
%in section \ref{sec:scatter-gather} may be omitted to reduce implementation
%complexity.
%
%An implementation must support all variants of {\tt SCATTER} and {\tt GATHER}
%or none.
%
%If {\tt SCATTER} and {\tt GATHER} instructions are not implemented, then their
%opcodes will cause the implementation to raise an {\em Illegal Instruction}
%exception.

%Many algorithms rely on bringing together non-contiguous data from memory,
%operating on it as a unit, then placing the results non-contiguously back
%into memory. Scatter / Gather instructions are variants of normal load/store
%instructions which allow a set of offsets (rather that just one) to be
%specified and the data at each offset loaded/stored into a single word
%as appropriate.

%%%The \ASM{SCATTER} and \ASM{GATHER} instructions are designed to be used as
%%%s-box lookup instructions. The {\tt .b} variants allow four separate lookups
%%%per instruction into a 256 entry LUT stored in memory, while the {\tt .h}
%%%variants allow two lookups into a 16-bit LUT stored in memory. \ASM{GATHER}
%%%will move the looked-up values from memory into a register, while \ASM{SCATTER}
%%%will move bytes of a register word back into the LUT in memory.
%%%\designnote{
%%%    While it is of-course possible to emulate the {\tt .h} variants of
%%%    \ASM{SCATTER} and \ASM{GATHER} with the {\tt.b} variants, we felt that
%%%    the performance and efficency savings to be had from telling the hardware
%%%    explicitly to work on halfwords were worth the extra instructions.
%%%}
%%%
%%%The address $a_x$ of each byte/halfword to be loaded or stored is computed by
%%%adding an offset $x$ from the {\tt offsets} $\XCR$ register, and adding it
%%%to the $base$ $\GPR$ register. For the {\tt .b} variants, there are four
%%%offsets each corresponding to the four bytes of the offsets source register
%%%word. For the {\tt .h} variant, there are two offsets corresponding to the
%%%upper and lower halfwords of the registers.
%%%
%%%Both instructions use the $\GPR$s to source their base address, while the
%%%offset indices into the LUT come from the $\XCR$ registers. This mirrors
%%%how the ISE load and store instructions compute their addresses.
%%%
%%%The scatter instruction requires three register file reads.
%%%Because the reads are split across the $\GPR$ and $\XCR$ registers,
%%%no {\em extra} ports are needed on the RISC-V register file beyond the
%%%standard two-read-one-write set.
%%%
%%%An implementation may perform the memory accesses in any order. The instructions
%%%will raise address misalignment exceptions in line with how misalignment is
%%%handled in the rest of the ISA.
%%%
%%%If any of the memory accesses cause
%%%a {\em load access fault, load page fault, store page fault} or
%%%{\em store access fault} then the address of the access which caused the
%%%exception is written to the {\tt MTVAL} csr. The value taken by the
%%%destination register bytes should an exception occur at any point in the
%%%instruction is {\em implementation dependent}.
%%%
%%%Implementations may abort execution of \ASM{SCATTER} or \ASM{GATHER} part way
%%%though in order to service an interrupt. If the instructions are aborted
%%%early, the value taken by the destination register bytes is {\em
%%%implementation dependent}. The implementation is responsible for ensuring
%%%that the {\tt EPC} register is set appropriately depending on whether the
%%%interrupt is taken during, or at the end of, the instruction.
%%%\designnote{Implementation of these instructions should consider the impact of
%%%shared memory systems, since it will be possible for other agents in the
%%%system to access memory during the execution of this instruction. In systems
%%%possessing a cache, programmers must be mindful that these instructions
%%%can cause odd behaviour due to the non-linear access pattern the instruction
%%%creates.}
%%%
%%%The rationale for these instructions is two fold. They help with code density,
%%%since at-least four instructions worth of work can now be done
%%%in one instruction. They can also help with energy efficiency, since fewer
%%%instructions need to be fetched and travel through an execution pipeline in
%%%order to achieve the same goal. They are not designed to enhance performance
%%%(in terms of cycles to complete an operation), but this may be a side-effect
%%%of some implementations.

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:bg:feature:2:3}

Particularly wrt. symmetric primitives, the use of bit-oriented operations 
is common in implementations of cryptography.  At a high level, and though 
counterexamples do exist 
(see, e.g., IDEA~\cite{SCARV:LaiMas:90}, RC6~\cite{SCARV:RRSY:98}),
this fact can be explained by use of alternative (i.e., not word-oriented
and/or not supported by arithmetic in most ISAs) structures and concepts,
and thus operations, in relevant designs.  Associated design rationale may
include
a) security
   (e.g., bit-sliced implementation~\cite{SCARV:KasSch:09} AES~\cite{SCARV:FIPS:197} to mitigate cache-based side-channel attacks),
   or
b) efficiency
   (e.g., use of hardware-friendly bit-permutations in DES~\cite{SCARV:FIPS:46_3})
As a result, numerous proposals for associated ISEs exist; these typically
act to accelerate in software what would otherwise represent a high (even 
prohibitive) overhead.  \XCID adopts a similar approach.

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.4$: packed}
\label{sec:bg:feature:2:4}

%It is common for some CPUs / DSP extensions to allow packed ALU operations.
%This is essentially using the normal GPRs to do SIMD operations on multiple
%pieces of data which are either a halfword or a byte in size. We include
%variants of such instructions which operate on data widths commonly
%found in cryptographic algorithms, particularly block ciphers.

% case in point, PRESENT; post-quantum schemes mod 2^{16}




%By default, the packed arithmetic width instructions detailed in
%section \ref{sec:packed-arithmetic-instructions} support operations on
%packed bit-fields of widths $2$, $4$, $8$, $16$ and $32$.
%
%For extremely resource constrained or application specific implementations,
%some unnecessary pack widths (as defined by the implementer) may be omitted.
%
%Supported pack widths are indicated by the {\tt pX} bits of the
%\nameref{sec:csr-mccr}.
%
%Packed arithmetic instructions operating on supported pack widths are
%executed as normal. If a packed arithmetic instruction operating on an
%unsupported pack width is encountered, the implementation should raise an
%{\em Illegal Instruction} exception.

% -----------------------------------------------------------------------------

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:bg:feature:2:5}

Modular, multi-precision integer arithmetic forms a foundation for various
cryptographic use-cases, but particularly asymmetric primitives; examples 
include
RSA (relying on arithmetic in $\B{Z}_N$ for large $N$),
and
ECC (relying on arithmetic in $\B{F}_p$ for large $p$).
As such, there is a large body of literature on the implementation of said 
arithmetic; this includes support for implementations via ISEs defined for 
RISC-based processors.

\XCID includes a suite of instructions 
(e.g., \VERB[RV]{ADD3.mp})
which mirror low-level steps in higher-level algorithms for multi-precision 
integer arithmetic; in part, these mirror features in 
XS1~\cite[Section 18]{SCARV:XS1:09} 
there termed ``long arithmetic''.  A central design principle is that every
instruction explicitly accepts {\em all} input required: this implies there
is no additional
explicit (e.g., accumulator register) 
nor 
implicit (e.g., status flags for carry or borrow)
state.
Such an approach is particularly attractive when set within the context of 
RV32I, because it avoids inclusion of status flags and so forces (somewhat 
high overhead) software-based carry and overflow detection.

% =============================================================================
