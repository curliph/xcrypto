\subsection{\XCID instructions}
\label{sec:spec:instr}

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:spec:instr:1}

% -----------------------------------------------------------------------------

\XCINSTR{MV2GPR}{rd, crs1}{
  \iencmvtwogpr
}{
  Move a $\XCR$ register to a $\GPR$ register.
}{ 
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{MV2COP}{crd, rs1}{
  \iencmvtwocop
}{
  Move a $\GPR$ register to a $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \GPR[*][{\VERB[RV]{rs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{CMOV.cr}{crd, crs1, crs2}{
  \ienccmovcr
}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] =    0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{CMOVN.cr}{crd, crs1, crs2}{
  \ienccmovncr
}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] \neq 0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{LBU.cr}{crd, h, b, imm11(rs1)}{
  \ienclbucr
}{
  Load a     byte from memory
  into a specific     byte of a $\XCR$ register,
  leaving the other     bytes in said register un-modified.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS \VERB[RV]{cd}} \ASN \MEM[*][{addr  }]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LHU.cr}{crd, h,    imm11(rs1)}{
  \ienclhucr
}{
  Load a halfword from memory
  into a specific halfword of a $\XCR$ register,
  leaving the other halfword  in said register un-modified.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             1} \ASN \MEM[*][{addr+1}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LW.cr}{crd,        imm11(rs1)}{
  \ienclwcr
}{
  Load a     word from memory 
  into                        a $\XCR$ register.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SB.cr}{rs2, h, b, imm11(rs1)}{
  \iencsbcr
}{
  Store a specific     byte of a $\XCR$ register into memory.
  Note that
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr  ] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS \VERB[RV]{cd}}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SH.cr}{rs2, h,    imm11(rs1)}{
  \iencshcr
}{
  Store a specific halfword of a $\XCR$ register into memory.
  Note that
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SW.cr}{rs2,       imm11(rs1)}{
  \iencswcr
}{
  Store                        a $\XCR$ register into memory.
  Note that
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
 $addr             \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                1}$ \;
  $\MEM[*][addr+2] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                2}$ \;
  $\MEM[*][addr+3] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                3}$ \;
}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:spec:instr:2:1}

% -----------------------------------------------------------------------------

\XCINSTR{RSEED.cr}{crs1}{
  \iencrseedcr
}{
  Inject (or seed) $32$-bits of entropy into the RNG, reading from a $\XCR$ register.
}{
  $\RNG \ASN \XCR[*][{\VERB[RV]{crs1}}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{RSAMP.cr}{crd}{
  \iencrsampcr
}{
  Sample           $32$-bits of entropy from the RNG, writing to   a $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \RNG$ \;
}

% =============================================================================

\subsubsection{Class-$2.2$: memory}
\label{sec:spec:instr:2:2}

% -----------------------------------------------------------------------------

\XCINSTR{SCATTER.b}{crd, rs2, crs2}{
  \iencscatterb
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\MEM[*][addr_0  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_1  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_2  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_3  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SCATTER.h}{crd, rs2, crs2}{
  \iencscatterh
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\MEM[*][addr_0+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_0+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_1+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_1+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{GATHER.b}{crd, rs1, crs2}{
  \iencgatherb
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_1  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_2  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_3  ]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{GATHER.h}{rd, rs1, crs2}{
  \iencgatherh
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_0+1]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_1+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_1+1]$ \;
}

% =============================================================================

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:spec:instr:2:3}

\XCINSTR{LLI.cr}{crd, imm16}{
  \iencllicr
}{
  Load an immediate halfword
  into the lower (or least-significant) halfword of a $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LUI.cr}{crd, imm16}{
  \iencluicr
}{
  Load an immediate halfword
  into the upper (or  most-significant) halfword of a $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
%\designnote{The RISC-V version of \ASM{LUI} is both for constant creation
%(in tandem with \ASM{ORI} and loading addresses.
%Since the zeroing of the low 12 bits by \ASM{LUI} is mainly useful 
%for addresses, we remove this functionality in favour of leaving the
%low half of the register unmodified.
%The rationale being that two instructions can still create and 32-bit
%immediate, but that if we know a register is zero to begin
%with, we can then use only one instruction to create masks which fit
%into only a single halfword.}
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{BOP.cr}{crd, crs1, crs2, lut4}{
  \iencbopcr
}{
%The BOP.cr instruction is designed to express all bitwise logic functions, and be
%amenable to bit-sliced implementations of cryptographic functions.
%
%BOP.cr takes a 4-bit immediate {\tt lut4}, and uses the concatenated
%$i$'th bits of register inputs $\XCR[*][crs1]$ and  $\XCR[*][crs2]$
%as the inputs, writing the output bit of the lut to the $i$'th bit of the
%destination register.
%\designnote{
%    This instruction must be implemented with care, since a naive
%    implementation will end up with a 32-port LUT, with correspondingly
%    poor timing performance.
%}
}{
  \For{$i = 0$ {\bf upto} $31$} {
    $index \ASN \INDEX{\XCR[*][crs1]}{i} \CONS \INDEX{\XCR[*][crs2]}{i}$ \;
    $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\VERB[RV]{lut4}}{index}$ \;
  }
}

%\paragraph{Examples:}
%\begin{itemize}
%\item {\tt bop.cr  c1, c2, c3, 0001    // AND}
%\item {\tt bop.cr  c1, c2, c3, 0111    // OR }
%\item {\tt bop.cr  c1, c2, c3, 0110    // XOR}
%\end{itemize}
%These examples of BOP.cr show how to encode the existing
%bitwise operation instructions found in the base RISC-V architecture.

% -----------------------------------------------------------------------------

\XCINSTR{EXT.cr}{crd, crs, cs, cl}{
  \iencextcr
}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from              one $\XCR$ register, and
  insert them as the LSBs in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \ASN \INDEX{\XCR[*][{\VERB[RV]{crs}}]}{hi \RANGE lo}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{INS.cr}{crd, crs, cs, cl}{
  \iencinscr
}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from the LSBSs of one $\XCR$ register, and
  insert   them           in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crs}}]}{hi \RANGE lo}$ \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \;
}

% -----------------------------------------------------------------------------

% TODO: shamt -> rtamt
\XCINSTR{LMIX.cr}{rd, rs1, rs2, shamt}{
  \ienclmixcr
}{
%The MIX.cr instruction allows an arbitrary bit-wise mixing of two
%register values, using a mask stored in a third register.
%It first rotates  the source register value in {\tt rs1} by the amount in
%{\tt shamt}, and then mixes the rotated value and the source value according
%to the mask value in {\tt rs2}.
%
%\ASM{LMIX.cr} will rotate the the value in {\tt rs1} to the right by $0..15$,
%while \ASM{HMIX.cr} will rotate to the right by $16..31$. 
%\designnote{This decision was made simply to make the encoding space
%easier to manage. Rather than adding another 5-bit immediate field, it was
%more efficient to re-use the 4-bit lut field of the BOP.cr
%instruction.}
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT}   \VERB[RV]{shamt}       $ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \eIf{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 0$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i}$
    }
  }
}

%\paragraph{Examples:}
%\ASM{MIX.cr} allows us to create any mix of bits from two registers
%using a single 3-instruction sequence:
%
%\begin{itemize}
%\item{\tt LUI.cr   c0, 0xF0F0     // Load a mask into c0 which will select}
%\item{\tt LLI.cr   c0, 0xF0F0     // alternate nibbles from each register}
%\item{\tt LMIX.cr  c2, c1, c0, 0  // Odd nibbles from c1, even nibbles from c2.}
%\item{\tt LMIX.cr  c3, c1, c0, 4  // Even nibbles from c1, even nibbles from c3.}
%\item{\tt LMIX.cr  c4, c1, c0, 4  // Odd  nibbles from c1, even nibbles from c3.}
%\end{itemize}
%}

% -----------------------------------------------------------------------------

% TODO: shamt -> rtamt
\XCINSTR{HMIX.cr}{rd, rs1, rs2, shamt}{
  \ienchmixcr
}{
%The MIX.cr instruction allows an arbitrary bit-wise mixing of two
%register values, using a mask stored in a third register.
%It first rotates  the source register value in {\tt rs1} by the amount in
%{\tt shamt}, and then mixes the rotated value and the source value according
%to the mask value in {\tt rs2}.
%
%\ASM{LMIX.cr} will rotate the the value in {\tt rs1} to the right by $0..15$,
%while \ASM{HMIX.cr} will rotate to the right by $16..31$. 
%\designnote{This decision was made simply to make the encoding space
%easier to manage. Rather than adding another 5-bit immediate field, it was
%more efficient to re-use the 4-bit lut field of the BOP.cr
%instruction.}
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT} ( \VERB[RV]{shamt} + 16 )$ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \eIf{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 0$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i}$
    }
  }
}

% =============================================================================

\subsubsection{Class-$2.4$: packed}
\label{sec:spec:instr:2:4}

%When coding these instructions as assembly mnemonics, the {\tt x} in the
%instruction names below should be replaced with the pack width. Hence
%for pack width 4, \ASM{SLLI.px} becomes \ASM{SLL.p4}.

% -----------------------------------------------------------------------------

\XCINSTR{ADD.px}{pw, crd, crs1, crs2}{
  \iencaddpx
}{
%The instruction \ASM{ADD.px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned packed fields, and adds corresponding fields
%together ignoring any carry bits.
%
%No overflow conditions are tested for, and \ASM{ADD.px} raises no exceptions.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{+}      \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{SUB.px}{pw, crd, crs1, crs2}{
  \iencsubpx
}{
%The instruction \ASM{SUB.px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and subtracts the {\tt rs2} fields
%from the corresponding {\tt rs1} fields.
%
%No overflow conditions are tested for, and \ASM{SUB.px} raises no exceptions.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{-}      \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{MUL.px}{pw, crd, crs1, crs2}{
  \iencmulpx
}{
%The instruction \ASM{MUL.px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and multiplies the {\tt rs2} fields
%by the corresponding {\tt rs1} fields.
%
%No overflow conditions are tested for, and \ASM{MUL.px} raises no exceptions.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\times} \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{SLL.px}{pw, crd, crs1, crs2}{
  \iencsllpx
}{
%The instruction \ASM{SLL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SLLI.px}) or {\tt rs2} 
%(for \ASM{SLL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SLL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LSH}   \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{SLLI.px}{pw, crd, crs1, cshamt}{
  \iencsllipx
}{
%The instruction \ASM{SLL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SLLI.px}) or {\tt rs2} 
%(for \ASM{SLL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SLL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LSH}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{SRL.px}{pw, crd, crs1, crs2}{
  \iencsrlpx
}{
%The instruction \ASM{SRL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SRLI.px}) or {\tt rs2} 
%(for \ASM{SRL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SRL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\RSH}   \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{SRLI.px}{pw, crd, crs1, cshamt}{
  \iencsrlipx
}{
%The instruction \ASM{SRL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SRLI.px}) or {\tt rs2} 
%(for \ASM{SRL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SRL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\RSH}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{ROT.px}{pw, crd, crs1, crs2}{
  \iencrotpx
}{
%The instruction \ASM{ROT[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and rotates the {\tt rs1} fields
%left by the value in {\tt CCSHAMT} (for \ASM{ROTI.px}) or {\tt rs2} 
%(for \ASM{ROT.px}).
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LRT}   \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{ROTI.px}{pw, crd, crs1, cshamt}{
  \iencrotipx
}{
%The instruction \ASM{ROT[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and rotates the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{ROTI.px}) or {\tt rs2} 
%(for \ASM{ROT.px}).
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LRT}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{TWID.B}{crd, crs1, b0, b1, b2, b3}{
  \ienctwidb
}{
  Permute bytes   of               some $\XCR$ register,
  storing the result in               another $\XCR$ register.
}{
  $t \ASN            \XCR[*][{\VERB[RV]{crs}}]               $ \;
  $           \XCR[*][{\VERB[RV]{crd}}]                \ASN \INDEX[ 8]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{TWID.Nx}{crd, crs1, b0, b1, b2, b3}{
  \ienctwidnzero
  \ienctwidnone
}{
  Permute nibbles of a halfword in some $\XCR$ register,
  storing the result in a halfword of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[16]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 4]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{TWID.Cx}{crd, crs1, b0, b1, b2, b3}{
  \ienctwidczero
  \ienctwidcone
  \ienctwidctwo
  \ienctwidcthree
}{
  Permute crumbs  of a byte     in some $\XCR$ register,
  storing the result in a byte     of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1, 2, 3 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 2]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b0}} $ \;
}

% =============================================================================

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:spec:instr:2:5}

%These instructions use two destination registers and between three
%and four source registers. Hence, some restrictions are placed on how
%registers can be addressed.
%
%\begin{itemize}
%\item
%Destination registers are referred too as contiguous, even-odd pairs.
%This means any two adjacently addressed registers, where the
%first register address is even (zero being considered even for this
%discussion) and the second address is one more than the first can be
%used as the destination for a multi-precision instructions.
%\designnote{
%    This scheme means the function to compute the actual source registers
%    from the minimum 3-bit encoding is simply to append either {\tt 00}
%    or {\tt 01} depending on the even or odd address respectively.
%}
%
%For example, $(0,1), (2,3)$ and $(10,11)$ are all valid
%pairs of destination registers.
%$(5,6)$ is not valid because the first
%is an odd number. $(6,5)$ is not valid because $6 > 5$.
%The pair $(6,9)$
%is not valid because $6$ and $9$ are not adjacent.
%
%\item
%The 3-bit encoding of pairs of registers is given in table 
%\ref{tab:rdm-encodings}.
%\end{itemize}
%
%\begin{table}[t]
%\centering
%\begin{tabular}{lll}
%\hline
%Encoding & crd2 & crd1 \\ \hline
%0b000      & 1    & 0    \\
%0b001      & 3    & 2    \\
%0b010      & 5    & 4    \\
%0b011      & 7    & 8    \\
%0b100      & 9    & 10   \\
%0b101      & 11   & 12   \\
%0b110      & 13   & 14   \\
%0b111      & 15   & 16   \\ \hline
%\end{tabular}
%\caption{
%    Table showing how the {\tt rdm} field of multi-precision instructions
%    is decoded into pairs of registers.
%}
%\label{tab:rdm-encodings}
%\end{table}
%
% -----------------------------------------------------------------------------

\XCINSTR{ADD2.mp}{(crd2, crd1), crs1, crs2      }{
  \iencaddtwomp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ADD3.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencaddthreemp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SUB2.mp}{(crd2, crd1), crs1, crs2      }{
  \iencsubtwomp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] )  $\;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SUB3.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencsubthreemp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{-} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ACC1.mp}{(crd2, crd1), crs1      }{
  \iencacconemp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ACC2.mp}{(crd2, crd1), crs1, crs2}{
  \iencacctwomp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}] 
                                                                                                   \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MAC.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencmacmp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\times} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+}      \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SLL.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencsllmp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\LSH} \XCR[*][{\VERB[RV]{crs3}}]_{5:0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;

}

% -----------------------------------------------------------------------------

\XCINSTR{SLLI.mp}{(crd2, crd1), crs1, crs2, shamt}{
  \iencsllimp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\LSH} shamt$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SRL.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencsrlmp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\RSH} \XCR[*][{\VERB[RV]{crs3}}]_{5:0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;

}

% -----------------------------------------------------------------------------

\XCINSTR{SRLI.mp}{(crd2, crd1), crs1, crs2, shamt}{
  \iencsrlimp
}{
  Note that 
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\RSH} shamt$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;

}

% -----------------------------------------------------------------------------

\XCINSTR{EQU.mp}{rd, crs1, crs2, crs3}{
  \ienceqump
}{

}{
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( \XCR[*][{\VERB[RV]{crs1}}] = \XCR[*][{\VERB[RV]{crs2}}])                                                                     \AND \XCR[*][{\VERB[RV]{crs3}}]  $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LTU.mp}{rd, crs1, crs2, crs3}{
  \iencltump
}{

}{
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( \XCR[*][{\VERB[RV]{crs1}}] < \XCR[*][{\VERB[RV]{crs2}}] ) \IOR ( ( \XCR[*][{\VERB[RV]{crs1}}] = \XCR[*][{\VERB[RV]{crs2}}] ) \AND \XCR[*][{\VERB[RV]{crs3}}] )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{GTU.mp}{rd, crs1, crs2, crs3}{
  \iencgtump
}{

}{
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( \XCR[*][{\VERB[RV]{crs1}}] > \XCR[*][{\VERB[RV]{crs2}}] ) \IOR ( ( \XCR[*][{\VERB[RV]{crs1}}] = \XCR[*][{\VERB[RV]{crs2}}] ) \AND \XCR[*][{\VERB[RV]{crs3}}] )$ \;
}

% =============================================================================
