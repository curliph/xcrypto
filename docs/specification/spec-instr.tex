\subsection{\XCID instructions}
\label{sec:spec:instr}

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:spec:instr:1}

% -----------------------------------------------------------------------------

\XCINSTR{MV2GPR}{rd, crs1}{
  \iencmvtwogpr
}{
  Move a $\XCR$ register to a $\GPR$ register.
}{ 
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{MV2COP}{crd, rs1}{
  \iencmvtwocop
}{
  Move a $\GPR$ register to a $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \GPR[*][{\VERB[RV]{rs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{CMOV.cr}{crd, crs1, crs2}{
  \ienccmovcr
}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] =    0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{CMOVN.cr}{crd, crs1, crs2}{
  \ienccmovncr
}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] \neq 0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{LBU.cr}{crd, h, b, imm11(rs1)}{
  \ienclbucr
}{
  Load a     byte from memory
  into a specific     byte of a $\XCR$ register,
  leaving the other     bytes in said register un-modified.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS \VERB[RV]{cd}} \ASN \MEM[*][{addr  }]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LHU.cr}{crd, h,    imm11(rs1)}{
  \ienclhucr
}{
  Load a halfword from memory
  into a specific halfword of a $\XCR$ register,
  leaving the other halfword  in said register un-modified.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             1} \ASN \MEM[*][{addr+1}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LW.cr}{crd,        imm11(rs1)}{
  \ienclwcr
}{
  Load a     word from memory 
  into                        a $\XCR$ register.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SB.cr}{rs2, h, b, imm11(rs1)}{
  \iencsbcr
}{
  Store a specific     byte of a $\XCR$ register into memory.
  Note that
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr  ] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS \VERB[RV]{cd}}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SH.cr}{rs2, h,    imm11(rs1)}{
  \iencshcr
}{
  Store a specific halfword of a $\XCR$ register into memory.
  Note that
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SW.cr}{rs2,       imm11(rs1)}{
  \iencswcr
}{
  Store                        a $\XCR$ register into memory.
  Note that
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
 $addr             \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                1}$ \;
  $\MEM[*][addr+2] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                2}$ \;
  $\MEM[*][addr+3] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                3}$ \;
}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:spec:instr:2:1}

% -----------------------------------------------------------------------------

\XCINSTR{RSEED.cr}{crs1}{
  \iencrseedcr
}{
  Inject (or seed) $32$-bits of entropy into the RNG, reading from a $\XCR$ register.
}{
  $\RNG \ASN \XCR[*][{\VERB[RV]{crs1}}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{RSAMP.cr}{crd}{
  \iencrsampcr
}{
  Sample           $32$-bits of entropy from the RNG, writing to   a $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \RNG$ \;
}

% =============================================================================

\subsubsection{Class-$2.2$: memory-related operations}
\label{sec:spec:instr:2:2}

% TODO: crd should be a source?
\XCINSTR{SCATTER.b}{rs, base, offsets}{
  \iencscatterb
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\MEM[*][addr_0  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{0}$ \;
  $\MEM[*][addr_1  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{1}$ \;
  $\MEM[*][addr_2  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{2}$ \;
  $\MEM[*][addr_3  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{3}$ \;
}

% TODO: crd should be a source?
\XCINSTR{SCATTER.h}{rs, base, offsets}{
  \iencscatterh
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\MEM[*][addr_0+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{0}$ \;
  $\MEM[*][addr_0+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{1}$ \;
  $\MEM[*][addr_1+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{2}$ \;
  $\MEM[*][addr_1+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{rs}}]}{3}$ \;
}

\XCINSTR{GATHER.b}{crd, rs1, crs2}{
  \iencgatherb
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_1  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_2  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_3  ]$ \;
}

\XCINSTR{GATHER.h}{rd, rs1, crs2}{
  \iencgatherh
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_0+1]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_1+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_1+1]$ \;
}

% =============================================================================

\subsubsection{Class-$2.3$: bit-oriented operations}
\label{sec:spec:instr:2:3}

\XCINSTR{LLI.cr}{crd, imm16}{
  \iencllicr
}{
  Load an immediate halfword
  into the lower (or least-significant) halfword of a $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \VERB[RV]{imm16}$ \;
}

\XCINSTR{LUI.cr}{crd, imm16}{
  \iencluicr
}{
  Load an immediate halfword
  into the upper (or  most-significant) halfword of a $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
%\designnote{The RISC-V version of \ASM{LUI} is both for constant creation
%(in tandem with \ASM{ORI} and loading addresses.
%Since the zeroing of the low 12 bits by \ASM{LUI} is mainly useful 
%for addresses, we remove this functionality in favour of leaving the
%low half of the register unmodified.
%The rationale being that two instructions can still create and 32-bit
%immediate, but that if we know a register is zero to begin
%with, we can then use only one instruction to create masks which fit
%into only a single halfword.}
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \VERB[RV]{imm16}$ \;
}

\XCINSTR{BOP.cr}{crd, crs1, crs2, lut4}{
  \iencbopcr
}{
%The BOP.cr instruction is designed to express all bitwise logic functions, and be
%amenable to bit-sliced implementations of cryptographic functions.
%
%BOP.cr takes a 4-bit immediate {\tt lut4}, and uses the concatenated
%$i$'th bits of register inputs $\XCR[*][crs1]$ and  $\XCR[*][crs2]$
%as the inputs, writing the output bit of the lut to the $i$'th bit of the
%destination register.
%\designnote{
%    This instruction must be implemented with care, since a naive
%    implementation will end up with a 32-port LUT, with correspondingly
%    poor timing performance.
%}
}{
  \For{$i = 0$ {\bf upto} $31$} {
    $index \ASN \INDEX{\XCR[*][crs1]}{i} \CONS \INDEX{\XCR[*][crs2]}{i}$ \;
    $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\VERB[RV]{lut4}}{index}$ \;
  }
}

%\paragraph{Examples:}
%\begin{itemize}
%\item {\tt bop.cr  c1, c2, c3, 0001    // AND}
%\item {\tt bop.cr  c1, c2, c3, 0111    // OR }
%\item {\tt bop.cr  c1, c2, c3, 0110    // XOR}
%\end{itemize}
%These examples of BOP.cr show how to encode the existing
%bitwise operation instructions found in the base RISC-V architecture.

%\instdescx{EXT.cr}
%{\iencextcr}
%{
%This instruction allows for extraction of contiguous sequences of two-bit
%pairs from words.
%It takes a two bit aligned start index {\tt s}, and a length
%{\tt l}, and extracts bits from $2*s$ to $(2*s)+(2*l)$, depositing them in
%the destination register.
%}{
%\begin{itemize}
%\item \INST{EXT.cr rd, rs, s, l}{
%    $b \ASN 2*s$\\
%    $e \ASN 2*l + b$\\
%    $\XCR[*][rd][e:0] \ASN \XCR[*][rs][e:b]$
%}
%\end{itemize}
%}{}
%
%
%\instdescx{INS.cr}
%{\iencinscr}
%{
%This instruction allows for insertion of a contiguous sequences of two-bit
%pairs into words.
%It takes the low $2*l$ bits of $\XCR[*][rs]$ and inserts them
%into $\XCR[*][rd]$, starting at bit position $2*s$.
%}{
%\begin{itemize}
%\item \INST{INS.cr rd, rs, s, l}{
%    $b \ASN 2*s$\\
%    $e \ASN 2*l + b$\\
%    $\XCR[*][rd][e:b] \ASN \XCR[*][rs][e:0]$
%}
%\end{itemize}
%}{}

% TODO: lu4 should be imm4 or shamt?
\XCINSTR{LMIX.cr}{rd, rs1, rs2, shamt}{
  \ienclmixcr
}{
%The MIX.cr instruction allows an arbitrary bit-wise mixing of two
%register values, using a mask stored in a third register.
%It first rotates  the source register value in {\tt rs1} by the amount in
%{\tt shamt}, and then mixes the rotated value and the source value according
%to the mask value in {\tt rs2}.
%
%\ASM{LMIX.cr} will rotate the the value in {\tt rs1} to the right by $0..15$,
%while \ASM{HMIX.cr} will rotate to the right by $16..31$. 
%\designnote{This decision was made simply to make the encoding space
%easier to manage. Rather than adding another 5-bit immediate field, it was
%more efficient to re-use the 4-bit lut field of the BOP.cr
%instruction.}
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT}   \VERB[RV]{shamt}       $ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \eIf{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 0$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i}$
    }
  }
}

% TODO: lu4 should be imm4 or shamt?
\XCINSTR{HMIX.cr}{rd, rs1, rs2, shamt}{
  \ienchmixcr
}{
%The MIX.cr instruction allows an arbitrary bit-wise mixing of two
%register values, using a mask stored in a third register.
%It first rotates  the source register value in {\tt rs1} by the amount in
%{\tt shamt}, and then mixes the rotated value and the source value according
%to the mask value in {\tt rs2}.
%
%\ASM{LMIX.cr} will rotate the the value in {\tt rs1} to the right by $0..15$,
%while \ASM{HMIX.cr} will rotate to the right by $16..31$. 
%\designnote{This decision was made simply to make the encoding space
%easier to manage. Rather than adding another 5-bit immediate field, it was
%more efficient to re-use the 4-bit lut field of the BOP.cr
%instruction.}
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT} ( \VERB[RV]{shamt} + 16 )$ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \eIf{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 0$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i}$
    }
  }
}

%\paragraph{Examples:}
%\ASM{MIX.cr} allows us to create any mix of bits from two registers
%using a single 3-instruction sequence:
%
%\begin{itemize}
%\item{\tt LUI.cr   c0, 0xF0F0     // Load a mask into c0 which will select}
%\item{\tt LLI.cr   c0, 0xF0F0     // alternate nibbles from each register}
%\item{\tt LMIX.cr  c2, c1, c0, 0  // Odd nibbles from c1, even nibbles from c2.}
%\item{\tt LMIX.cr  c3, c1, c0, 4  // Even nibbles from c1, even nibbles from c3.}
%\item{\tt LMIX.cr  c4, c1, c0, 4  // Odd  nibbles from c1, even nibbles from c3.}
%\end{itemize}
%}

% =============================================================================

\subsubsection{Class-$2.4$: packed operations}
\label{sec:spec:instr:2:4}

%When coding these instructions as assembly mnemonics, the {\tt x} in the
%instruction names below should be replaced with the pack width. Hence
%for pack width 4, \ASM{SLLI.px} becomes \ASM{SLL.p4}.

\XCINSTR{ADD.px}{pw, crd, crs1, crs2}{
  \iencaddpx
}{
%The instruction \ASM{ADD.px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned packed fields, and adds corresponding fields
%together ignoring any carry bits.
%
%No overflow conditions are tested for, and \ASM{ADD.px} raises no exceptions.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{+}      \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

\XCINSTR{SUB.px}{pw, crd, crs1, crs2}{
  \iencsubpx
}{
%The instruction \ASM{SUB.px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and subtracts the {\tt rs2} fields
%from the corresponding {\tt rs1} fields.
%
%No overflow conditions are tested for, and \ASM{SUB.px} raises no exceptions.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{-}      \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

\XCINSTR{MUL.px}{pw, crd, crs1, crs2}{
  \iencmulpx
}{
%The instruction \ASM{MUL.px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and multiplies the {\tt rs2} fields
%by the corresponding {\tt rs1} fields.
%
%No overflow conditions are tested for, and \ASM{MUL.px} raises no exceptions.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\times} \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

\XCINSTR{SLL.px}{pw, crd, crs1, crs2}{
  \iencsllpx
}{
%The instruction \ASM{SLL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SLLI.px}) or {\tt rs2} 
%(for \ASM{SLL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SLL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LSH}   \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

\XCINSTR{SLLI.px}{pw, crd, crs1, cshamt}{
  \iencsllipx
}{
%The instruction \ASM{SLL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SLLI.px}) or {\tt rs2} 
%(for \ASM{SLL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SLL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LSH}   \VERB[RV]{cshamt}$ \;
  }
}

\XCINSTR{SRL.px}{pw, crd, crs1, crs2}{
  \iencsrlpx
}{
%The instruction \ASM{SRL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SRLI.px}) or {\tt rs2} 
%(for \ASM{SRL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SRL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\RSH}   \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

\XCINSTR{SRLI.px}{pw, crd, crs1, cshamt}{
  \iencsrlipx
}{
%The instruction \ASM{SRL[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and shifts the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{SRLI.px}) or {\tt rs2} 
%(for \ASM{SRL.px}).
%
%If the distance to shift by is greater than or equal to the size of each
%packed field, then the result of the \ASM{SRL[I].px} instruction is
%{\em implementation dependent}.
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\RSH}   \VERB[RV]{cshamt}$ \;
  }
}

\XCINSTR{ROT.px}{pw, crd, crs1, crs2}{
  \iencrotpx
}{
%The instruction \ASM{ROT[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and rotates the {\tt rs1} fields
%left by the value in {\tt CCSHAMT} (for \ASM{ROTI.px}) or {\tt rs2} 
%(for \ASM{ROT.px}).
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LRT}   \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

\XCINSTR{ROTI.px}{pw, crd, crs1, cshamt}{
  \iencrotipx
}{
%The instruction \ASM{ROT[I].px} treats the source and destination registers as
%1, 2, 4, 8 or 16 unsigned, packed fields, and rotates the {\tt rs1} fields
%left by the value in {\tt CSHAMT} (for \ASM{ROTI.px}) or {\tt rs2} 
%(for \ASM{ROT.px}).
  Note that
  $
  \VERB[RV]{pw} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  \For{$i = 0$ {\bf upto} $( 32 / \VERB[RV]{pw} ) - 1$}{
    $\INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[{\VERB[RV]{pw}}]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[{\VERB[RV]{pw}}][u]{\LRT}   \VERB[RV]{cshamt}$ \;
  }
}

%\instdescx{TWID.B}
%{\ienctwidb}
%{
%The \ASM{TWID.B} instruction is used to twiddle {\em bytes within words.}
%It arbitrarily maps the bytes of a source word onto the bytes of a
%destination word.
%This instruction doubles as a halfword permutation instruction.
%}{
%\begin{itemize}
%\item \INST{TWID.B crd, crs1, b0, b1, b2, b3}{
%    $bytes \ASN \LIST{\XCR[*][crs1][31:24],
%                      \XCR[*][crs1][23:16],
%                      \XCR[*][crs1][15: 8],
%                      \XCR[*][crs1][ 7: 0]}$\\
%    $ \XCR[*][{\VERB[RV]{crd}}] \ASN bytes[\VERB[RV]{b3}] \CONS
%                               bytes[\VERB[RV]{b2}] \CONS
%                               bytes[\VERB[RV]{b1}] \CONS
%                               bytes[\VERB[RV]{b0}] $ 
%}
%\end{itemize}
%}{}
%
%\instdescx{TWID.Nx}
%{\ienctwidnzero\ienctwidnone}
%{
%The \ASM{TWID.Nx} instruction is used to twiddle {\em nibbles within 
%half-words}.
%It works on the {\tt x}'th halfword of a register word where
%$x\in{0,1}.$.
%}{
%\begin{itemize}
%\item \INST{TWID.N0 crd, crs1, b0, b1, b2, b3}{
%$ \XCR[*][{\VERB[RV]{crd}}][15: 0] \ASN nibbles[\VERB[RV]{b3}] \CONS
%                               nibbles[\VERB[RV]{b2}] \CONS
%                               nibbles[\VERB[RV]{b1}] \CONS
%                               nibbles[\VERB[RV]{b0}] $ \\
%$ \XCR[*][{\VERB[RV]{crd}}][31:16] \ASN \XCR[*][\VERB[RV]{crs1}][31:16]$ \\
%}
%\item \INST{TWID.N1 crd, crs1, b0, b1, b2, b3}{
%$ \XCR[*][{\VERB[RV]{crd}}][15: 0] \ASN \XCR[*][\VERB[RV]{crs1}][15: 0]$ \\
%$ \XCR[*][{\VERB[RV]{crd}}][31:16] \ASN nibbles[\VERB[RV]{b3}] \CONS
%                               nibbles[\VERB[RV]{b2}] \CONS
%                               nibbles[\VERB[RV]{b1}] \CONS
%                               nibbles[\VERB[RV]{b0}] $ \\
%}
%\end{itemize}
%}{}
%
%
%\instdescx{TWID.Cx}
%{\ienctwidczero\ienctwidcone\ienctwidctwo\ienctwidcthree}
%{
%The \ASM{TWID.[Cx]} instruction is used to twiddle {\em pairs of bits
%\footnote{A {\em crumb}, if you will.}
%within bytes}.
%It works on the {\tt x}'th byte of a register word where
%$x\in{0,1,2,3}.$.
%}{
%\begin{itemize}
%\item \INST{TWID.C0 crd, crs1, b0, b1, b2, b3}{
%$ \XCR[*][{\VERB[RV]{crd}}][ 7: 0] \ASN crumbs[\VERB[RV]{b3}] \CONS
%                                  crumbs[\VERB[RV]{b2}] \CONS
%                                  crumbs[\VERB[RV]{b1}] \CONS
%                                  crumbs[\VERB[RV]{b0}] $ \\
%$ \XCR[*][{\VERB[RV]{crd}}][31: 8] \ASN \XCR[*][\VERB[RV]{crs1}][31: 8]$\\
%}
%\item \INST{TWID.C1 crd, crs1, b0, b1, b2, b3}{
%$ \XCR[*][{\VERB[RV]{crd}}][ 7: 0] \ASN \XCR[*][\VERB[RV]{crs1}][ 7: 0]$\\
%$ \XCR[*][{\VERB[RV]{crd}}][15: 8] \ASN crumbs[\VERB[RV]{b3}] \CONS
%                                  crumbs[\VERB[RV]{b2}] \CONS
%                                  crumbs[\VERB[RV]{b1}] \CONS
%                                  crumbs[\VERB[RV]{b0}] $ \\
%$ \XCR[*][{\VERB[RV]{crd}}][31:16] \ASN \XCR[*][\VERB[RV]{crs1}][31:16]$\\
%}
%\item \INST{TWID.C2 crd, crs1, b0, b1, b2, b3}{
%$ \XCR[*][{\VERB[RV]{crd}}][15: 0] \ASN \XCR[*][\VERB[RV]{crs1}][15: 0]$\\
%$ \XCR[*][{\VERB[RV]{crd}}][23:16] \ASN crumbs[\VERB[RV]{b3}] \CONS
%                                  crumbs[\VERB[RV]{b2}] \CONS
%                                  crumbs[\VERB[RV]{b1}] \CONS
%                                  crumbs[\VERB[RV]{b0}] $ \\
%$ \XCR[*][{\VERB[RV]{crd}}][31:24] \ASN \XCR[*][\VERB[RV]{crs1}][31:24]$\\
%}
%\item \INST{TWID.C3 crd, crs1, b0, b1, b2, b3}{
%$ \XCR[*][{\VERB[RV]{crd}}][23: 0] \ASN \XCR[*][\VERB[RV]{crs1}][23: 0]$\\
%$ \XCR[*][{\VERB[RV]{crd}}][31:24] \ASN crumbs[\VERB[RV]{b3}] \CONS
%                                  crumbs[\VERB[RV]{b2}] \CONS
%                                  crumbs[\VERB[RV]{b1}] \CONS
%                                  crumbs[\VERB[RV]{b0}] $ \\
%}
%\end{itemize}
%}{}

% =============================================================================

\subsubsection{Class-$2.5$: multi-precision integer operations}
\label{sec:spec:instr:2:5}

%These instructions use two destination registers and between three
%and four source registers. Hence, some restrictions are placed on how
%registers can be addressed.
%
%\begin{itemize}
%\item
%Destination registers are referred too as contiguous, even-odd pairs.
%This means any two adjacently addressed registers, where the
%first register address is even (zero being considered even for this
%discussion) and the second address is one more than the first can be
%used as the destination for a multi-precision instructions.
%\designnote{
%    This scheme means the function to compute the actual source registers
%    from the minimum 3-bit encoding is simply to append either {\tt 00}
%    or {\tt 01} depending on the even or odd address respectively.
%}
%
%For example, $(0,1), (2,3)$ and $(10,11)$ are all valid
%pairs of destination registers.
%$(5,6)$ is not valid because the first
%is an odd number. $(6,5)$ is not valid because $6 > 5$.
%The pair $(6,9)$
%is not valid because $6$ and $9$ are not adjacent.
%
%\item
%The 3-bit encoding of pairs of registers is given in table 
%\ref{tab:rdm-encodings}.
%\end{itemize}
%
%\begin{table}[t]
%\centering
%\begin{tabular}{lll}
%\hline
%Encoding & crd2 & crd1 \\ \hline
%0b000      & 1    & 0    \\
%0b001      & 3    & 2    \\
%0b010      & 5    & 4    \\
%0b011      & 7    & 8    \\
%0b100      & 9    & 10   \\
%0b101      & 11   & 12   \\
%0b110      & 13   & 14   \\
%0b111      & 15   & 16   \\ \hline
%\end{tabular}
%\caption{
%    Table showing how the {\tt rdm} field of multi-precision instructions
%    is decoded into pairs of registers.
%}
%\label{tab:rdm-encodings}
%\end{table}
%
% -----------------------------------------------------------------------------

\XCINSTR{ADD2.mp}{(crd2, crd1), crs1, crs2      }{
  \iencaddtwomp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32]{u}{+} \XCR[*][{\VERB[RV]{crs2}}] )$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ADD3.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencaddthreemp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32]{u}{+} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[32]{u}{+} \XCR[*][{\VERB[RV]{crs3}}]  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SUB2.mp}{(crd2, crd1), crs1, crs2      }{
  \iencsubtwomp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32]{u}{-} \XCR[*][{\VERB[RV]{crs2}}] )$\;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SUB3.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencsubthreemp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32]{u}{-} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[32]{u}{-} \XCR[*][{\VERB[RV]{crs3}}]  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ACC1.mp}{(crd2, crd1), crs1      }{
  \iencacconemp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[{64}]{u}{+} \XCR[*][{\VERB[RV]{crs1}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ACC2.mp}{(crd2, crd1), crs1, crs2}{
  \iencacctwomp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64]{u}{+} \XCR[*][{\VERB[RV]{crs1}}] 
                                                                                                   \OP[64]{u}{+} \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MAC.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencmacmp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32]{u}{\cdot} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[32]{u}{+}     \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[64:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SLL.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencsllmp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \LSH \XCR[*][{\VERB[RV]{crs3}}]_{5:0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;

}

% -----------------------------------------------------------------------------

\XCINSTR{SLLI.mp}{(crd2, crd1), crs1, crs2, shamt}{
  \iencsllimp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \LSH shamt$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SRL.mp}{(crd2, crd1), crs1, crs2, crs3}{
  \iencsrlmp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \RSH \XCR[*][{\VERB[RV]{crs3}}]_{5:0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;

}

% -----------------------------------------------------------------------------

\XCINSTR{SRLI.mp}{(crd2, crd1), crs1, crs2, shamt}{
  \iencsrlimp
}{
  Note that 
  $
  \TUPLE{ \VERB[RV]{crd1}, \VERB[RV]{crd2} } \mapsto \VERB[RV]{crdm} .
  $
}{
  $t                          \ASN (\XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}]) \RSH shamt$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN t[31: 0]$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN t[63:32]$ \;

}

% -----------------------------------------------------------------------------

\XCINSTR{EQU.mp}{rd, crs1, crs2, crs3}{
  \ienceqump
}{

}{
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( \XCR[*][{\VERB[RV]{crs1}}] = \XCR[*][{\VERB[RV]{crs2}}])                                                                     \AND \XCR[*][{\VERB[RV]{crs3}}]  $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LTU.mp}{rd, crs1, crs2, crs3}{
  \iencltump
}{

}{
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( \XCR[*][{\VERB[RV]{crs1}}] < \XCR[*][{\VERB[RV]{crs2}}] ) \IOR ( ( \XCR[*][{\VERB[RV]{crs1}}] = \XCR[*][{\VERB[RV]{crs2}}] ) \AND \XCR[*][{\VERB[RV]{crs3}}] )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{GTU.mp}{rd, crs1, crs2, crs3}{
  \iencgtump
}{

}{
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( \XCR[*][{\VERB[RV]{crs1}}] > \XCR[*][{\VERB[RV]{crs2}}] ) \IOR ( ( \XCR[*][{\VERB[RV]{crs1}}] = \XCR[*][{\VERB[RV]{crs2}}] ) \AND \XCR[*][{\VERB[RV]{crs3}}] )$ \;
}

% =============================================================================
