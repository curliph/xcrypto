\subsection{\XCID instructions}
\label{sec:spec:instr}

% TODO: mnemonic prefix/suffix rules

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:spec:instr:1}

% -----------------------------------------------------------------------------

\XCINSTR{XCR2GPR}{rd, crs1}{
  \iencxcrtwogpr
}{
  Move a $\XCR$ register to a $\GPR$ register.
}{ 
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{GPR2XCR}{crd, rs1}{
  \iencgprtwoxcr
}{
  Move a $\GPR$ register to a $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \GPR[*][{\VERB[RV]{rs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{CMOV.cr}{crd, crs1, crs2}{
  \ienccmovcr
}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] =    0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{CMOVN.cr}{crd, crs1, crs2}{
  \ienccmovncr
}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] \neq 0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{LD.BU}{crd, h, b, imm11(rs1)}{
  \iencldbu
}{
  Load a     byte from memory
  into a specific     byte of a $\XCR$ register,
  leaving the other     bytes in said register un-modified.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS \VERB[RV]{cd}} \ASN \MEM[*][{addr  }]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LD.HU}{crd, h,    imm11(rs1)}{
  \iencldhu
}{
  Load a halfword from memory
  into a specific halfword of a $\XCR$ register,
  leaving the other halfword  in said register un-modified.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             1} \ASN \MEM[*][{addr+1}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LD.W}{crd,        imm11(rs1)}{
  \iencldw
}{
  Load a     word from memory 
  into                        a $\XCR$ register.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ST.B}{rs2, h, b, imm11(rs1)}{
  \iencstb
}{
  Store a specific     byte of a $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr  ] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS \VERB[RV]{cd}}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ST.H}{rs2, h,    imm11(rs1)}{
  \iencsth
}{
  Store a specific halfword of a $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{cc} \CONS             1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{ST.W}{rs2,       imm11(rs1)}{
  \iencstw
}{
  Store                        a $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
 $addr             \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                1}$ \;
  $\MEM[*][addr+2] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                2}$ \;
  $\MEM[*][addr+3] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{                                3}$ \;
}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:spec:instr:2:1}

% -----------------------------------------------------------------------------

\XCINSTR{RNGSEED}{crs1}{
  \iencrngseed
}{
  Inject (or seed) $32$-bits of entropy into the RNG, reading from a $\XCR$ register.
}{
  $\RNG \ASN \XCR[*][{\VERB[RV]{crs1}}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{RNGSAMP}{crd}{
  \iencrngsamp
}{
  Sample           $32$-bits of entropy from the RNG, writing to   a $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \RNG$ \;
}

% =============================================================================

\subsubsection{Class-$2.2$: memory}
\label{sec:spec:instr:2:2}

% -----------------------------------------------------------------------------

\XCINSTR{SCATTER.b}{crd, rs2, crs2}{
  \iencscatterb
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\MEM[*][addr_0  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_1  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_2  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_3  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{SCATTER.h}{crd, rs2, crs2}{
  \iencscatterh
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\MEM[*][addr_0+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_0+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_1+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_1+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{GATHER.b}{crd, rs1, crs2}{
  \iencgatherb
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_1  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_2  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_3  ]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{GATHER.h}{rd, rs1, crs2}{
  \iencgatherh
}{

}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_0+1]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_1+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_1+1]$ \;
}

% =============================================================================

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:spec:instr:2:3}

\XCINSTR{LD.LI}{crd, imm16}{
  \iencldli
}{
  Load an immediate halfword
  into the lower (or least-significant) halfword of a $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{LD.HI}{crd, imm16}{
  \iencldhi 
}{
  Load an immediate halfword
  into the upper (or  most-significant) halfword of a $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{BOP}{crd, crs1, crs2, lut4}{
  \iencbop
}{
  Compute the $i$-bit of a result by apply a $2$-input, $1$-output Boolean 
  function $f$ to corresponding $i$-th bits of two operands.  The function
  $f$ is specified as a look-up table \VERB[RV]{lut4}, so the instruction 
  essentially computes
  $
  \INDEX{r}{i} = f( \INDEX{x}{i}, \INDEX{y}{i} ) = \INDEX{\VERB[RV]{lut4}}{x_i \CONS y_i}
  $
  for $x$, $y$, and $r$, all in $\XCR$ registers.  Note that since
  \[
  \begin{array}{l@{\;}c@{\;}l c l@{\;}c@{\;}l}
  \VERB[RV]{lut4} &=& \RADIX{1000}{2} &\Longrightarrow& f &=& \AND \\
  \VERB[RV]{lut4} &=& \RADIX{1110}{2} &\Longrightarrow& f &=& \IOR \\
  \VERB[RV]{lut4} &=& \RADIX{0110}{2} &\Longrightarrow& f &=& \XOR \\
  \end{array}
  \]
  the instructions
  \VERB[RV]{AND.cr}, \VERB[RV]{AND.cr}, and \VERB[RV]{AND.cr}
  can be, and are, synthesised using \VERB[RV]{BOP.cr}.
}{
  \For{$i = 0$ {\bf upto} $31$} {
    $index \ASN \INDEX{\XCR[*][crs1]}{i} \CONS \INDEX{\XCR[*][crs2]}{i}$ \;
    $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\VERB[RV]{lut4}}{index}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{EXT}{crd, crs, cs, cl}{
  \iencext
}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from              one $\XCR$ register, and
  insert them as the LSBs in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \ASN \INDEX{\XCR[*][{\VERB[RV]{crs}}]}{hi \RANGE lo}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{INS}{crd, crs, cs, cl}{
  \iencins
}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from the LSBSs of one $\XCR$ register, and
  insert   them           in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crs}}]}{hi \RANGE lo}$ \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \;
}

% -----------------------------------------------------------------------------

% TODO: shamt -> rtamt?
\XCINSTR{MIX.l}{rd, rs1, rs2, shamt}{
  \iencmixl
}{
  Form a result by mix together bits from two operands based on a mask:
  the instruction essentially computes  
  \[
  \INDEX{r}{i} = \left\{\begin{array}{ll}
                        \INDEX{x}{i} \OP[32][u]{\RRT}   \VERB[RV]{shamt}        & \mbox{~if $\INDEX{m}{i} = 0$} \\
                        \INDEX{r}{i}                                            & \mbox{~otherwise            } \\
                        \end{array}
                        \right.
  \]
  for $r$, $x$, and $m$ in $\XCR$ registers,
  and for each 
  $
  0 \leq i < 32 .
  $ 
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT}   \VERB[RV]{shamt}       $ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \If{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 0$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }
  }
}

% -----------------------------------------------------------------------------

% TODO: shamt -> rtamt?
\XCINSTR{MIX.h}{rd, rs1, rs2, shamt}{
  \iencmixh
}{
  Form a result by mix together bits from two operands based on a mask:
  the instruction essentially computes  
  \[
  \INDEX{r}{i} = \left\{\begin{array}{ll}
                        \INDEX{x}{i} \OP[32][u]{\RRT} ( \VERB[RV]{shamt} + 16 ) & \mbox{~if $\INDEX{m}{i} = 0$} \\
                        \INDEX{r}{i}                                            & \mbox{~otherwise            } \\
                        \end{array}
                        \right.
  \]
  for $r$, $x$, and $m$ in $\XCR$ registers,
  and for each 
  $
  0 \leq i < 32 .
  $ 
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT} ( \VERB[RV]{shamt} + 16 )$ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \If{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 0$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }
  }
}

% =============================================================================

\subsubsection{Class-$2.4$: packed}
\label{sec:spec:instr:2:4}

Each instruction in this class computes a packed operation: for an operator
$\odot$, register or immediate variants essentially compute

\begin{enumerate}
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot} \INDEX[w]{y}{i}$,
      for $r$, $x$, and $y$ in $\XCR$ registers.
      and
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot}           y    $,
      for $r$,      and $x$ in $\XCR$ registers, and an $y$ immediate,
\end{enumerate}

\noindent
and for each 
$
0 \leq i < \VERB[RV]{n} ,
$ 
where the field count
$
\VERB[RV]{n} \in \SET{ 2, 4, 8, 16, 32 }
$ 
specified in the instruction encoding implies a field width of 
$
w = 32 / \VERB[RV]{n} .
$

% -----------------------------------------------------------------------------

\XCINSTR{PADD}{pw, crd, crs1, crs2}{
  \iencpadd
}{
  Compute a   register-based packed addition, 
  implying $\odot = +$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{+}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{PSUB}{pw, crd, crs1, crs2}{
  \iencpsub
}{
  Compute a   register-based packed subtraction, 
  implying $\odot = -$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{-}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{PMUL.l}{pw, crd, crs1, crs2}{
  \iencpmull
}{
  Compute a   register-based packed multiplication, 
  implying $\odot = \times$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{PSLL}{pw, crd, crs1, crs2}{
  \iencpsll
}{
  Compute a   register-based packed left-shift,
  implying $\odot = \LSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

% TODO: cshamt => pshamt ?
\XCINSTR{PSLL.i}{pw, crd, crs1, cshamt}{
  \iencpslli
}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \LSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ,
  $
  and that any out-of-range distance
  $
  \VERB[RV]{cshamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{PSRL}{pw, crd, crs1, crs2}{
  \iencpsrl
}{
  Compute a   register-based packed right-shift,
  implying $\odot = \RSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

% TODO: cshamt => pshamt ?
\XCINSTR{PSRL.i}{pw, crd, crs1, cshamt}{
  \iencpsrl
}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \RSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ,
  $
  and that any out-of-range distance
  $
  \VERB[RV]{cshamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{PROT}{pw, crd, crs1, crs2}{
  \iencprot
}{
  Compute a   register-based packed left-rotate,
  implying $\odot = \LRT$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ,
  $
  and that the effective distance is
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \pmod{w} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LRT}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{PROT.i}{pw, crd, crs1, cshamt}{
  \iencproti
}{
  Compute an immediate-based packed left-rotate,
  implying $\odot = \LRT$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ,
  $
  and that the effective distance is
  $
  \VERB[RV]{cshamt} \pmod{w} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LRT}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{PPERM.W}{crd, crs1, b0, b1, b2, b3}{
  \iencppermw
}{
  Permute bytes   of               some $\XCR$ register,
  storing the result in               another $\XCR$ register.
}{
  $t \ASN            \XCR[*][{\VERB[RV]{crs}}]               $ \;
  $           \XCR[*][{\VERB[RV]{crd}}]                \ASN \INDEX[ 8]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{PPERM.Hx}{crd, crs1, b0, b1, b2, b3}{
  \iencppermhzero
  \iencppermhone
}{
  Permute nibbles of a halfword in some $\XCR$ register,
  storing the result in a halfword of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[16]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 4]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{PPERM.Bx}{crd, crs1, b0, b1, b2, b3}{
  \iencppermbzero
  \iencppermbone
  \iencppermbtwo
  \iencppermbthree
}{
  Permute crumbs  of a byte     in some $\XCR$ register,
  storing the result in a byte     of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1, 2, 3 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 2]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b0}} $ \;
}

% =============================================================================

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:spec:instr:2:5}

Instruction in this class use upto
$4$ source      $\XCR$ registers
and
$2$ destination $\XCR$ registers,
which demands some compromises wrt. the encoding used.
In short, a compressed specification of the destination $\XCR$ registers is
used, whereby a single encoded \VERB[RV]{crdm} field implies (or maps to) a 
pair 
$
\TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} }
$
of register addresses st.
a) $\VERB[RV]{crd2} = \VERB[RV]{crd1} + 1$
   (the contiguousness rule),
   and
b) $\VERB[RV]{crd2} = 1 \pmod{2}$
   and 
   $\VERB[RV]{crd1} = 0 \pmod{2}$
   (the  odd-even'ness rule).
Concretely then, this means
\[
\begin{array}{l@{\;}c@{\;}r c c@{\;}l@{\;}c@{\;}r@{\;}c@{\;}l@{\;}c@{\;}r@{\;}c}
\VERB[RV]{crdm} &=& \RADIX{000}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  1 &,& \VERB[RV]{crd1} &=&  0 & ) \\
\VERB[RV]{crdm} &=& \RADIX{001}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  3 &,& \VERB[RV]{crd1} &=&  2 & ) \\
\VERB[RV]{crdm} &=& \RADIX{010}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  5 &,& \VERB[RV]{crd1} &=&  4 & ) \\
\VERB[RV]{crdm} &=& \RADIX{011}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  7 &,& \VERB[RV]{crd1} &=&  6 & ) \\
\VERB[RV]{crdm} &=& \RADIX{100}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  9 &,& \VERB[RV]{crd1} &=&  8 & ) \\
\VERB[RV]{crdm} &=& \RADIX{101}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 11 &,& \VERB[RV]{crd1} &=& 10 & ) \\
\VERB[RV]{crdm} &=& \RADIX{110}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 13 &,& \VERB[RV]{crd1} &=& 12 & ) \\
\VERB[RV]{crdm} &=& \RADIX{111}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 15 &,& \VERB[RV]{crd1} &=& 14 & ) \\
\end{array}
\]
where
$\TUPLE{ 1, 0 }$ and $\TUPLE{ 3, 2 }$ are deemed valid pairs,
$\TUPLE{ 3, 0 }$ is invalid because it violates the contiguousness rule,
$\TUPLE{ 2, 3 }$ is invalid because it violates the contiguousness rule,
and
$\TUPLE{ 2, 1 }$ is invalid because it violates the  odd-even'ness rule.

% -----------------------------------------------------------------------------

\XCINSTR{MADD.2}{(crd2, crd1), crs1, crs2      }{
  \iencmaddtwo
}{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a half-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MADD.3}{(crd2, crd1), crs1, crs2, crs3}{
  \iencmaddthree
}{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the carry-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a full-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MSUB.2}{(crd2, crd1), crs1, crs2      }{
  \iencmsubtwo
}{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a half-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MSUB.3}{(crd2, crd1), crs1, crs2, crs3}{
  \iencmsubthree
}{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the borrow-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a full-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{-} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MACC.1}{(crd2, crd1), crs1      }{
  \iencmaccone
}{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs1}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MACC.2}{(crd2, crd1), crs1, crs2}{
  \iencmacctwo
}{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addends
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}] 
                                                                                                   \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MMUL.1}{(crd2, crd1), crs1, crs2, crs3}{
  \iencmmulone
}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate:
  the $32$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $64$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\times} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+}      \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MSLL}{(crd2, crd1), crs1, crs2, crs3}{
  \iencmsll
}{
  Compute a   register-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\LSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

% TODO: why 4-bit cmshamt?
\XCINSTR{MSLL.i}{(crd2, crd1), crs1, crs2, shamt}{
  \iencmslli
}{
  Compute an immediate-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\LSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MSRL}{(crd2, crd1), crs1, crs2, crs3}{
  \iencmsrl
}{
  Compute a   register-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\RSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

% TODO: why 4-bit cmshamt?
\XCINSTR{MSRL.i}{(crd2, crd1), crs1, crs2, shamt}{
  \iencmsrli
}{
  Compute an immediate-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] ) \OP[64][u]{\RSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MEQU}{rd, rs1, crs2, crs3}{
  \iencmequ
}{
  Compute a ``chained'' (or ``long'') 
  equality 
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_0            \AND \GPR[*][{\VERB[RV]{rs1}}]  $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MLTE}{rd, rs1, crs2, crs3}{
  \iencmlte
}{
  Compute a ``chained'' (or ``long'') 
     less-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] < \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{MGTE}{rd, rs1, crs2, crs3}{
  \iencmgte
}{
  Compute a ``chained'' (or ``long'') 
  greater-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] > \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% =============================================================================
