
Verification of the ISE implementation is done using a mixture of
directed testing using a golden reference model and formal methods.

\subsection{Verilog Golden Reference Model}

The GRM is be written using functional verilog.

\begin{itemize}
\item Each instruction is implemented as a verilog task.
\item The GRM has the same interface as the implementation.
\item The GRM snoops on the implementation interface and produces a
    predicted result for all instructions.
\item All transactions on the memory and CPU/COP interface will be modelled
    and checked against the GRM.
\end{itemize}

The GRM is only used as a basic sanity checker. Designers can use it to
develop hardware and get general functionality working before applying
formal checks.

The formal flow should be used to actually gain verification confidence
in the implementation.

\subsection{Formal Verification Flow}

The formal flow uses Yosys and Boolector as a model checker to ensure that
for any sequence of inputs, the implementation behaves correctly with
respect to the implementation.

% TODO: Flow graph

\subsubsection{Flow Method}

TBD

\subsubsection{Relevent Files}

These are the files and directories relevent to the formal flow:

\begin{itemize}
\item TBD
\end{itemize}

\subsubsection{Formal Flow Bug List}

This section is a {\em trophy cabinet} of bugs found using the formal
verification flow.

\begin{itemize}
\item Input instruction and RS1 data not registered properly by the COP during
    stalled or multi-cycle execution.
\item Memory read data polluting other writeback data when no memory
    instruction was active due to poorly gated and/or tree.
\item Memory bus error exception raised ahead of invalid opcode exception.
\item Memory bus errors being raised when no memory instruction was active.
\item Pack width instructions not raising invalid opcode exceptions for
    invalid pack widths.
\item Raising invalid pack width exceptions for instructions with no pack width
    fields.
\item Design shift amound fields 1 bit too big resulting in different results
    only when the pack width is 1.
\item Rotate instruction {\em model} was incorrect if the rotate ammount was
    greater than twice the pack width.
\item Insert bitfield instruction was blanking out destination beyond the
    bitfield.
\item All memory instructions were not recording transaction history correctly.
\item A bus error in the first cycle of a memory transaction caused memory
    transactions to be missed in the formal environment, even though it
    should have been ignored iff it was the first cycle of the transaction.
\item Scatter/Gather instruction addresses were not correctly registered
    by the formal verification interface.
\item Scatter instructions set write enable but no byte enable bits.
\item {\tt mgte} Instruction gave incorrect result iff crs2==crs3.
\item {\tt msrl} and {\tt msll} didn't give a 0 result if the shift
    amount was out of bounds.
\item {\tt mmul.1} was missing the final addition writeback due to not
    storing temporaries properly.
\item {\tt pmul.l} did not mask partial sums properly and was writing
    intermediate results to the register file.
\end{itemize}
