
Verification of the ISE implementation will be done using a mixture of
constrained random testing and formal methods.
Both methods will use the same single cycle, functional model of the ISE as a
golden reference model (GRM).
Outputs of the implementation will be compared against the GRM for
correctness.

\subsection{Verilog Golden Reference Model}

The GRM will be written using functional verilog.

\begin{itemize}
\item Each instruction will be implemented as a verilog task.
\item The GRM will have the same interface as the implementation.
\item The GRM will snoop on the implementation interface and produce a
    predicted result for all input instructions.
\item All transactions on the memory and CPU/COP interface will be modelled
    and checked against the GRM.
\end{itemize}

Using bounded model checking (BMC) the aim will be to make sure that after
$12$ clock ticks, the model and implementation have not diverged.
After that check is passed, we switch to induction mode and show that the two
will never diverge after that point.

We use $12$ clock ticks because it is enough for all combinations of 
instruction tripples to be executed and experience things like memory
and writeback stalling.

\subsection{Formal Verification Flow}

The formal flow will use Yosys as a model checker to ensure that for any
sequence of inputs, the outputs of the implementation and the GRM will remain
the same.

\subsubsection{Formal Flow Bug List}

This section is a {\em trophy cabinet} of bugs found using the formal
verification flow.

\begin{itemize}
\item Input instruction and RS1 data not registered properly by the COP during
    stalled or multi-cycle execution.
\item Memory read data polluting other writeback data when no memory
    instruction was active due to poorly gated and/or tree.
\item Memory bus error exception raised ahead of invalid opcode exception.
\item Memory bus errors being raised when no memory instruction was active.
\item Pack width instructions not raising invalid opcode exceptions for
    invalid pack widths.
\item Raising invalid pack width exceptions for instructions with no pack width
    fields.
\item Design shift amound fields 1 bit too big resulting in different results
    only when the pack width is 1.
\item Rotate instruction {\em model} was incorrect if the rotate ammount was
    greater than twice the pack width.
\item Insert bitfield instruction was blanking out destination beyond the
    bitfield.
\item All memory instructions were not recording transaction history correctly.
\item A bus error in the first cycle of a memory transaction caused memory
    transactions to be missed in the formal environment, even though it
    should have been ignored iff it was the first cycle of the transaction.
\item Scatter/Gather instruction addresses were not correctly registered
    by the formal verification interface.
\item Scatter instructions set write enable but no byte enable bits.
\item {\tt mgte} Instruction gave incorrect result iff crs2==crs3.
\item {\tt msrl} and {\tt msll} didn't give a 0 result if the shift
    amount was out of bounds.
\item {\tt mmul.1} was missing the final addition writeback due to not
    storing temporaries properly.
\item {\tt pmul.l} did not mask partial sums properly and was writing
    intermediate results to the register file.
\end{itemize}
