
Verification of the ISE implementation will be done using a mixture of
constrained random testing and formal methods.
Both methods will use the same single cycle, functional model of the ISE as a
golden reference model (GRM).
Outputs of the implementation will be compared against the GRM for
correctness.

\subsection{Verilog Golden Reference Model}

The GRM will be written using functional verilog.

\begin{itemize}
\item Each instruction will be implemented as a verilog task.
\item The GRM will have the same interface as the implementation.
\item The GRM will snoop on the implementation interface and produce a
    predicted result for all input instructions.
\item All transactions on the memory and CPU/COP interface will be modelled
    and checked against the GRM.
\end{itemize}

Using bounded model checking (BMC) the aim will be to make sure that after
$12$ clock ticks, the model and implementation have not diverged.
After that check is passed, we switch to induction mode and show that the two
will never diverge after that point.

We use $12$ clock ticks because it is enough for all combinations of 
instruction tripples to be executed and experience things like memory
and writeback stalling.

\subsection{Formal Verification Flow}

The formal flow will use Yosys as a model checker to ensure that for any
sequence of inputs, the outputs of the implementation and the GRM will remain
the same.

The following is a non-exhaustive list of checks which the formal flow
will include.

\subsubsection{CPU/COP Interface}

\begin{itemize}
\item Valid transitions for instruction request / acknowledge signals.
\item Data signals stable during instruction request stall.
\item Valid transitions for instruction response  / acknowledge signals.
\item Data signals stable during instruction response stall.
\item Response signal values match between model and DUT. Specificaly:
    write address, write data, COP result.
\item No exception response if instruction does not cause exception.
\item Only get an exception response iff exception occured.
\item No responses without corresponding request.
\end{itemize}

\subsubsection{COP Memory Interface}

\begin{itemize}
\item Correct number of memory transactions per instruction.
\item Correct address per transaction.
\item Correct write data per transaction.
\item Write Data/Address/Byte enable lines all stable during a stall.
\item Byte enable valid values / never all zeros during transaction.
\item Memory error / stall never asserted when chip enable is low.
\end{itemize}

\subsubsection{CPR Register Writes}

\begin{itemize}
\item Only expected registers are written too.
\item Only expected registers are read from.
\item Correct values are written.
\item Correct values are read.
\end{itemize}

\subsection{Constrained Random Flow}

The CRT flow will re-use much of the same environment of the formal flow,
but will allow loading of simple assembly program sequences into a
memory model. This will allow us to create a set of fast unit tests, and to
re-create bugs found in the formal flow.

